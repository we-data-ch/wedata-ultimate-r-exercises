{
  "hash": "a938eb9f7b561b13f90d288f6197a208",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Troubleshooting and Debugging in R\"\nauthor: \"David Munoz Tord\"\ndescription: \"Master essential techniques for identifying, understanding, and fixing errors in R code\"\nengine: knitr\ndate: \"2025-05-17\"\nformat: live-html\n---\n\n::: {.cell}\n\n:::\n\n\n\n\n\n## Course Overview\n\nWelcome to the Troubleshooting and Debugging in R course! Being able to effectively diagnose and fix errors is an essential skill for any R programmer. This course will teach you systematic approaches to identify common errors, use R's built-in debugging tools, and develop robust strategies for solving problems in your code.\n\nBy the end of this course, you will:\n* Understand common error message patterns and their meanings\n* Master debugging tools available in R\n* Apply systematic troubleshooting approaches\n* Gain confidence in solving coding problems independently\n\n---\n\n## Lesson 1: Understanding Error Messages\n\nWhen R code fails, the interpreter provides error messages that can help identify the issue. These messages often seem cryptic at first, but learning to interpret them is a valuable skill.\n\n### Types of Errors in R\n\nR errors generally fall into three main categories:\n\n1. **Syntax Errors**: Occur when code doesn't follow proper R syntax rules\n2. **Runtime Errors**: Occur during execution when R encounters an invalid operation\n3. **Logical Errors**: Code runs without errors but produces incorrect results\n\n### Reading Error Messages\n\nError messages in R typically contain:\n* The specific error encountered \n* The function where the error occurred\n* Sometimes, line numbers or context for the error\n\n**Example: Basic Error Messages**\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Syntax error (missing closing parenthesis)\nsum(1, 2, 3\n\n# Reference error (object not found)\nprint(nonexistent_variable)\n\n# Type error (incompatible data types)\n\"string\" + 5\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in parse(text = input): <text>:5:1: unexpected symbol\n4: # Reference error (object not found)\n5: print\n   ^\n```\n\n\n:::\n:::\n\n\n\n\nWhen facing errors, focus on these key parts:\n* The error message text itself\n* The function name mentioned\n* The context or line number\n* Any traceback information showing the call stack\n\n### Common Error Messages and Their Meanings\n\n**1. \"object not found\"**\nThis indicates trying to reference a variable or function that doesn\\'t exist in the current environment.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Common causes:\n# 1. Typos in variable names\nmean_value <- 10\nprint(mean_vlue)  # Typo in variable name\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError: object 'mean_vlue' not found\n```\n\n\n:::\n\n```{.r .cell-code}\n# 2. Forgetting to load a package\n# head(starwars)  # Without loading dplyr\n\n# 3. Variable exists in a different environment (scope)\nexample_function <- function() {\n  internal_variable <- 10\n}\n# After the function executes, trying to access:\n# print(internal_variable)  # Error: object not found\n```\n:::\n\n\n\n\n**2. \"cannot open the connection\"**\nThis error usually relates to file operations.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Trying to read a non-existent file\nread.csv(\"file_that_does_not_exist.csv\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in file(file, \"rt\"): cannot open file 'file_that_does_not_exist.csv':\nNo such file or directory\n```\n\n\n:::\n\n::: {.cell-output .cell-output-error}\n\n```\nError in file(file, \"rt\"): cannot open the connection\n```\n\n\n:::\n:::\n\n\n\n\n**3. \"argument is missing, with no default\"**\nFunctions require certain arguments, and this error occurs when you miss a required one.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# seq() requires at least \\'from\\' and \\'to\\'\nseq()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1\n```\n\n\n:::\n:::\n\n\n\n\n**4. \"non-numeric argument to binary operator\"**\nThis occurs when trying to perform mathematical operations on non-numeric values.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n\"hello\" * 3\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in \"hello\" * 3: non-numeric argument to binary operator\n```\n\n\n:::\n:::\n\n\n\n**Exercise 1.1: Identifying Error Types**\n\nFor each code snippet below:\n1. Run the code to see the error\n2. Identify the type of error (syntax, runtime, or logical)\n3. Explain what caused the error\n4. Fix the code to make it work\n\n\n\n\n::: {.cell exercise='ex1-1' solution_hidden='true'}\n```{webr}\n#| exercise: ex1-1\n#| solution_hidden: true\n\n# Code Snippet 1\ndat <- c(1, 2, 3, \"four\", 5)\nmean(dat)\n\n# Code Snippet 2\nvalues <- c(10, 20, 30, 40)\nfor (i in 1:5) {\n  print(values[i])\n}\n\n# Code Snippet 3\ncalculate_area <- function(length, width) {\n  area <- length * width\n  return(area)\n}\ncalculate_area(5)\n\n# Code Snippet 4\nx <- c(1, 2, 3\ny <- x + 1\nprint(y)\n```\n:::\n\n\n\n\n**Exercise 1.2: Understanding Error Messages**\n\nGiven the following error messages, determine the possible cause and how you would fix it:\n\n\n\n\n::: {.cell exercise='ex1-2' solution_hidden='true'}\n```{webr}\n#| exercise: ex1-2\n#| solution_hidden: true\n\n# 1. Error in data.frame(Name = c(\"Alice\", \"Bob\", \"Charlie\"), Age = c(25, 30),  : \n#    arguments imply differing number of rows: 3, 2\n\n# Your explanation:\n# The data.frame() function is being called with vectors of different lengths.\n# The 'Name' vector has 3 elements, but the 'Age' vector only has 2.\n# Fix: Make sure all vectors have the same length.\n\ndata_fixed <- data.frame(\n  Name = c(\"Alice\", \"Bob\", \"Charlie\"),\n  Age = c(25, 30, 35)  # Added the missing value\n)\nprint(data_fixed)\n\n# 2. Error in library(ggplot3) : there is no package called 'ggplot3'\n\n# Your explanation:\n# The package name is incorrect. The correct package name is 'ggplot2'.\n# Fix: Use the correct package name.\n\n# library(ggplot2)  # Correct package name\n\n# 3. Error: unexpected symbol in \"my result\"\n\n# Your explanation:\n# Variable names in R cannot contain spaces. \n# Fix: Use an underscore or period instead of a space.\n\nmy_result <- 42\nprint(my_result)\n\n```\n:::\n\n\n\n\n---\n\n## Lesson 2: Debugging Tools in R\n\nR provides several built-in tools to help with debugging. Understanding these tools can save enormous time when troubleshooting complex code.\n\n### Basic Debugging Approaches\n\nBefore diving into specialized functions, consider these basic strategies:\n\n**1. Print Statements**\nThe simplest debugging technique is to add `print()` or `cat()` statements at strategic points in your code.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncomplex_calculation <- function(x, y) {\n  print(paste(\"Input values:\", x, \"and\", y))\n  \n  intermediate_result <- x * y\n  print(paste(\"Intermediate result:\", intermediate_result))\n  \n  final_result <- intermediate_result + x\n  print(paste(\"Final result:\", final_result))\n  \n  return(final_result)\n}\n\ncomplex_calculation(5, 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Input values: 5 and 3\"\n[1] \"Intermediate result: 15\"\n[1] \"Final result: 20\"\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 20\n```\n\n\n:::\n:::\n\n\n\n\n**2. Using `str()` and `class()`**\nOften, errors occur because the data isn\\'t the type or structure you expect.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsample_data <- list(\n  numbers = 1:5,\n  text = \"hello world\",\n  matrix = matrix(1:9, nrow = 3)\n)\n\nstr(sample_data)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nList of 3\n $ numbers: int [1:5] 1 2 3 4 5\n $ text   : chr \"hello world\"\n $ matrix : int [1:3, 1:3] 1 2 3 4 5 6 7 8 9\n```\n\n\n:::\n\n```{.r .cell-code}\nclass(sample_data$numbers)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"integer\"\n```\n\n\n:::\n\n```{.r .cell-code}\nclass(sample_data$text)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"character\"\n```\n\n\n:::\n:::\n\n\n\n\n### Specialized Debugging Functions\n\nR provides several specialized debugging functions:\n\n**1. `traceback()`**\nAfter an error occurs, `traceback()` shows the sequence of function calls that led to the error.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Example of using traceback()\nf <- function() g()\ng <- function() h()\nh <- function() stop(\"Error in h\")\n\n# This would cause an error\n# f()\n\n# Then you can run:\n# traceback()\n# Which would show the calling sequence:\n# 3: stop(\"Error in h\") at #1\n# 2: h() at #1\n# 1: g() at #1\n# 0: f()\n```\n:::\n\n\n\n\n**2. `browser()`**\nInserts an interactive debugging environment at any point in your function.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndebug_calculation <- function(x, y) {\n  # This launches the browser when the function runs\n  browser()\n  \n  step1 <- x * 2\n  step2 <- y + 10\n  result <- step1 * step2\n  \n  return(result)\n}\n\n# When calling this function, execution will pause at browser()\n# debug_calculation(5, 3)\n\n# In the browser, you can:\n# - Type 'n' to execute the next statement\n# - Type 'c' to continue to the end of the function\n# - Type 'Q' to quit debugging\n# - Type variable names to see their values\n# - Execute any R code to inspect the environment\n```\n:::\n\n\n\n\n**3. `debug()` and `debugonce()`**\nMarks a function for debugging, activating browser mode when the function runs.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# debug() flags a function for debugging\n# debugonce() does it for just the next call\n\nsimple_function <- function(x) {\n  result <- x^2\n  return(result)\n}\n\n# debug(simple_function)\n# simple_function(5)\n# undebug(simple_function)\n\n# Or for a single use:\n# debugonce(simple_function)\n# simple_function(5)\n```\n:::\n\n\n\n\n**4. The Error Inspector in RStudio**\nWhen an error occurs in RStudio, you can often click on \"Show Traceback\" to see the call stack, and \"Rerun with Debug\" to enter debugging mode.\n\n### Using `try()` and `tryCatch()`\n\nFor more controlled error handling, R provides `try()` and `tryCatch()` functions.\n\n**1. `try()` - Continue execution despite errors**\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Without try(), this would stop execution\nresult1 <- try(1 + \"a\", silent = TRUE)\nprint(\"This code runs even after the error\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"This code runs even after the error\"\n```\n\n\n:::\n\n```{.r .cell-code}\n# Check if an error occurred\nif (inherits(result1, \"try-error\")) {\n  print(\"An error occurred in the first operation\")\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"An error occurred in the first operation\"\n```\n\n\n:::\n\n```{.r .cell-code}\n# Continue with other operations\nresult2 <- try(1 + 2)\nprint(paste(\"Second result:\", result2))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Second result: 3\"\n```\n\n\n:::\n:::\n\n\n\n\n**2. `tryCatch()` - More sophisticated error handling**\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nresult <- NULL # Initialize result\nresult <- tryCatch(\n  {\n    # The main code to try\n    x <- 1 / 0\n    return(x)  # This won't execute due to the error\n  },\n  error = function(e) {\n    # Code to run if an error occurs\n    message(\"An error occurred: \", e$message)\n    return(NA)  # Return a default value\n  },\n  warning = function(w) {\n    # Code to run if a warning occurs\n    message(\"A warning occurred: \", w$message)\n    return(NULL)\n  },\n  finally = {\n    # Code that always runs, regardless of error/warning\n    message(\"This cleanup code always runs\")\n  }\n)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nThis cleanup code always runs\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] Inf\n```\n\n\n:::\n\n```{.r .cell-code}\nprint(result)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNULL\n```\n\n\n:::\n:::\n\n\n\n\n**Exercise 2.1: Using Debugging Tools**\n\nPractice using different debugging techniques:\n\n\n\n\n::: {.cell exercise='ex2-1' solution_hidden='true'}\n```{webr}\n#| exercise: ex2-1\n#| solution_hidden: true\nresult <- NULL # Initialize result\nlibrary(tidyverse)\n\n# This function has an error. Use debugging tools to find and fix it.\ncalculate_statistics <- function(data) {\n  # Calculate the mean of each column\n  if (!is.data.frame(data)) {\n    stop(\"Input must be a data frame\")\n  }\n  \n  means <- colMeans(data)  # This will fail on non-numeric columns\n  \n  # Calculate standard deviations\n  sds <- sapply(data, sd)\n  \n  # Calculate ranges\n  ranges <- sapply(data, function(x) max(x) - min(x))\n  \n  # Return results\n  return(list(means = means, sds = sds, ranges = ranges))\n}\n\n# Create a test dataset\ntest_data <- data.frame(\n  a = 1:5,\n  b = c(5, 10, 15, 20, 25),\n  c = c(\"apple\", \"banana\", \"cherry\", \"date\", \"elderberry\")  # Non-numeric column\n)\n\n# Using try() to handle the error more gracefully\nresult <- try(calculate_statistics(test_data), silent = TRUE)\n\nif (inherits(result, \"try-error\")) {\n  print(\"Error detected! Let's debug...\")\n  \n  # 1. Identify the issue\n  print(\"Issue: The function fails because it tries to calculate statistics on a non-numeric column.\")\n  \n  # 2. Fix the function\n  calculate_statistics_fixed <- function(data) {\n    if (!is.data.frame(data)) {\n      stop(\"Input must be a data frame\")\n    }\n    \n    # Only select numeric columns\n    numeric_data <- data %>% select_if(is.numeric)\n    \n    if (ncol(numeric_data) == 0) {\n      stop(\"No numeric columns found in the data\")\n    }\n    \n    means <- colMeans(numeric_data)\n    sds <- sapply(numeric_data, sd)\n    ranges <- sapply(numeric_data, function(x) max(x) - min(x))\n    \n    return(list(means = means, sds = sds, ranges = ranges))\n  }\n  \n  # 3. Test the fixed function\n  result_fixed <- calculate_statistics_fixed(test_data)\n  print(\"Fixed function results:\")\n  print(result_fixed)\n}\n```\n:::\n\n\n\n\n**Exercise 2.2: Building Robust Functions**\n\nCreate a function with built-in error handling that calculates the square root of each element in a vector, but handles negative numbers gracefully.\n\n\n\n\n::: {.cell exercise='ex2-2' solution_hidden='true'}\n```{webr}\n#| exercise: ex2-2\n#| solution_hidden: true\nlibrary(tidyverse)\n\n# Complete this function with proper error handling\nsafe_sqrt <- function(x, handle_negative = TRUE) {\n  if (!is.numeric(x)) {\n    stop(\"Input must be numeric\")\n  }\n  \n  # Process each element with tryCatch\n  result <- sapply(x, function(val) {\n    tryCatch(\n      {\n        if (val < 0 && handle_negative) {\n          warning(paste(\"Taking square root of negative number:\", val))\n          return(complex(real = 0, imaginary = sqrt(abs(val))))\n        } else {\n          return(sqrt(val))\n        }\n      },\n      error = function(e) {\n        warning(paste(\"Error with value\", val, \":\", e$message))\n        return(NA)\n      }\n    )\n  })\n  \n  return(result)\n}\n\n# Test cases\ntest_vector1 <- c(4, 9, 16, 25)\ntest_vector2 <- c(4, -9, 16, \"string\")\ntest_vector3 <- c(4, -9, 16, 25)\n\n# Test with simple vector\nresult1 <- safe_sqrt(test_vector1)\nprint(\"Result 1 (all positive numbers):\")\nprint(result1)\n\n# Test with mixed types (should handle the error)\nresult2 <- try(safe_sqrt(test_vector2), silent = TRUE)\nprint(\"Result 2 (mixed types - should show error message):\")\nprint(result2)\n\n# Test with negative numbers\nresult3 <- safe_sqrt(test_vector3)\nprint(\"Result 3 (with negative number):\")\nprint(result3)\n\n# Test with handle_negative = FALSE\nresult4 <- try(safe_sqrt(test_vector3, handle_negative = FALSE), silent = TRUE)\nprint(\"Result 4 (negative numbers not allowed):\")\nprint(result4)\n```\n:::\n\n\n\n\n---\n\n## Lesson 3: Systematic Troubleshooting\n\nBeyond specific tools, developing a systematic approach to debugging will make you more efficient at solving problems. This section covers structured approaches to troubleshooting.\n\n### The Debugging Mindset\n\nEffective debugging requires:\n* Patience and persistence\n* Systematic, methodical thinking\n* Breaking complex problems into smaller parts\n* Formulating and testing hypotheses\n\n### Isolating the Problem\n\nWhen facing a complex error, try to:\n\n1. **Create a minimal reproducible example (reprex)**\n   * Strip down your code to the smallest version that still produces the error\n   * Remove unnecessary data or code that isn't relevant to the problem\n\n2. **Binary search debugging**\n   * Comment out half of your code to see if the error still occurs\n   * If it does, the problem is in the remaining half; if not, it's in the half you commented out\n   * Repeat this process, narrowing down the location of the error\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Example of code you might need to debug\ncomplex_function <- function() {\n  # Step 1 - Data loading\n  # ...\n  \n  # Step 2 - Data preprocessing\n  # ...\n  \n  # Step 3 - Analysis\n  # ...\n  \n  # Step 4 - Visualization\n  # ...\n}\n\n# Binary search approach:\n# 1. Comment out steps 3 & 4 to see if error occurs in steps 1 & 2\n# 2. If error still occurs, comment out step 2 to check if it's in step 1\n# 3. Continue narrowing down until you find the exact line\n```\n:::\n\n\n\n\n### Verifying Assumptions\n\nMany bugs stem from incorrect assumptions about:\n* What functions do\n* What data contains\n* The state of objects at different points in code execution\n\nAlways verify these assumptions:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Check function behavior with simple inputs\nhead(mtcars, 2)  # Make sure you understand what head() does\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n              mpg cyl disp  hp drat    wt  qsec vs am gear carb\nMazda RX4      21   6  160 110  3.9 2.620 16.46  0  1    4    4\nMazda RX4 Wag  21   6  160 110  3.9 2.875 17.02  0  1    4    4\n```\n\n\n:::\n\n```{.r .cell-code}\n# Check data types and structures\ntypeof(mtcars$mpg)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"double\"\n```\n\n\n:::\n\n```{.r .cell-code}\nis.data.frame(mtcars)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\ndim(mtcars)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 32 11\n```\n\n\n:::\n\n```{.r .cell-code}\n# Check for missing values\nsum(is.na(mtcars))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0\n```\n\n\n:::\n\n```{.r .cell-code}\n# Check for unexpected values\nsummary(mtcars$mpg)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  10.40   15.43   19.20   20.09   22.80   33.90 \n```\n\n\n:::\n\n```{.r .cell-code}\nrange(mtcars$mpg)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 10.4 33.9\n```\n\n\n:::\n:::\n\n\n\n\n### Using Version Control for Debugging\n\nVersion control systems like Git can be valuable debugging tools:\n\n1. **Bisect through commits**:\n   * If your code worked before, use `git bisect` to find which commit introduced the bug\n\n2. **Compare working and non-working versions**:\n   * Use `git diff` to see what changed between versions\n\n3. **Revert to a known good state**:\n   * When completely stuck, you can fall back to a version you know works\n\n### Rubber Duck Debugging\n\nSometimes, the mere act of explaining your code helps you spot the issue:\n\n1. Explain your code line by line to an inanimate object (or a patient colleague)\n2. Articulate what each line is supposed to do\n3. Describe the expected vs. actual behavior\n4. Often, you'll spot the issue while explaining\n\n**Exercise 3.1: Isolating Bugs**\n\nThe following function has multiple issues. Use a systematic approach to identify and fix them.\n\n\n\n\n::: {.cell exercise='ex3-1' solution_hidden='true'}\n```{webr}\n#| exercise: ex3-1\n#| solution_hidden: true\nlibrary(tidyverse)\n\n# This function attempts to calculate the mean of each column in a data frame,\n# after filtering rows based on a condition. It has several bugs.\nanalyze_data <- function(data, filter_col, min_value) {\n  # Step 1: Check input data\n  if (!is.data.frame(data)) {\n    stop(\"Input must be a data frame\")\n  }\n  \n  # Step 2: Filter the data\n  # Bug 1: Missing comma in filter syntax\n  filtered_data <- data[data[filter_col] > min_value]\n  \n  # Step 3: Calculate column means\n  # Bug 2: Using colMeans on a data frame that might contain non-numeric columns\n  result <- colMeans(filtered_data)\n  \n  # Step 4: Return results\n  # Bug 3: No return statement\n  result\n}\n\n# Test data\ntest_df <- data.frame(\n  id = 1:5,\n  value = c(10, 20, 30, 40, 50),\n  category = c(\"A\", \"B\", \"A\", \"C\", \"B\")\n)\n\n# Step 1: Test with simple inputs to identify errors\ntest_result <- try(analyze_data(test_df, \"value\", 25), silent = TRUE)\nif (inherits(test_result, \"try-error\")) {\n  print(\"First attempt failed with error\")\n}\n\n# Step 2: Fix bugs one by one\nanalyze_data_fixed <- function(data, filter_col, min_value) {\n  # Fix 1: Input validation\n  if (!is.data.frame(data)) {\n    stop(\"Input must be a data frame\")\n  }\n  \n  if (!filter_col %in% names(data)) {\n    stop(paste(\"Column\", filter_col, \"not found in data\"))\n  }\n  \n  # Fix 2: Proper filtering syntax\n  filtered_data <- data[data[[filter_col]] > min_value, ]\n  \n  # Fix 3: Handle empty result\n  if (nrow(filtered_data) == 0) {\n    warning(\"No rows match the filter criteria\")\n    return(NULL)\n  }\n  \n  # Fix 4: Calculate means only for numeric columns\n  numeric_cols <- sapply(filtered_data, is.numeric)\n  if (sum(numeric_cols) == 0) {\n    warning(\"No numeric columns found\")\n    return(NULL)\n  }\n  \n  result <- colMeans(filtered_data[, numeric_cols, drop = FALSE])\n  \n  # Fix 5: Explicit return\n  return(result)\n}\n\n# Test the fixed function\nfinal_result <- analyze_data_fixed(test_df, \"value\", 25)\nprint(\"Fixed function result:\")\nprint(final_result)\n\n# Test with a different filter\nfinal_result2 <- analyze_data_fixed(test_df, \"value\", 45)\nprint(\"Test with higher threshold (should include warning):\")\nprint(final_result2)\n```\n:::\n\n\n\n\n**Exercise 3.2: Creating a Minimal Reproducible Example**\n\nTake this complex and error-prone code and create a minimal reproducible example that isolates the core issue.\n\n\n\n\n::: {.cell exercise='ex3-2' solution_hidden='true'}\n```{webr}\n#| exercise: ex3-2\n#| solution_hidden: true\nlibrary(tidyverse)\n\n# Complex function with an error somewhere\nprocess_data <- function(data, group_var, measure_var, do_transform = TRUE) {\n  # Validate inputs\n  if (!is.data.frame(data) || !group_var %in% names(data) || !measure_var %in% names(data)) {\n    stop(\"Invalid inputs\")\n  }\n  \n  # Apply optional transformation\n  if (do_transform) {\n    data <- data %>%\n      mutate(across(where(is.numeric), ~ . + 100))\n  }\n  \n  # Group and summarize\n  result <- data %>%\n    group_by(across(all_of(group_var))) %>%\n    summarize(\n      mean_value = mean(!!sym(measure_var)),\n      count = n(),\n      .groups = \"drop\"\n    ) %>%\n    filter(count >= 2) %>%  # Error: Should be >= 1 if we want to keep all groups\n    arrange(desc(mean_value))\n  \n  # Make tidy names\n  names(result) <- str_replace_all(names(result), \"_\", \".\")\n  \n  return(result)\n}\n\n# Sample data\ntest_data <- data.frame(\n  group = c(\"A\", \"A\", \"B\", \"C\", \"C\", \"C\"),\n  value = c(1, 2, 3, 4, 5, 6)\n)\n\n# Try running the function - it'll drop group B because it has only one record\nresult_full <- try(process_data(test_data, \"group\", \"value\"), silent = TRUE)\n\n# Create a minimal reproducible example that isolates the issue\nminimal_reprex <- function() {\n  # Simplified data with just the key issue\n  simple_data <- data.frame(\n    group = c(\"A\", \"A\", \"B\"),\n    value = c(1, 2, 3)\n  )\n  \n  # Core issue: The filter(count >= 2) drops single-row groups\n  problem_result <- simple_data %>%\n    group_by(group) %>%\n    summarize(\n      count = n(),\n      .groups = \"drop\"\n    ) %>%\n    filter(count >= 2)  # This drops group B\n  \n  print(\"Minimal example showing the issue:\")\n  print(problem_result)  # Only shows group A, drops B\n  \n  # Fix:\n  result_fixed <- simple_data %>%\n    group_by(group) %>%\n    summarize(\n      count = n(),\n      .groups = \"drop\"\n    ) %>%\n    filter(count >= 1)  # Keep all groups\n  \n  print(\"Fixed version:\")\n  print(result_fixed)  # Shows both groups A and B\n  \n  return(result_fixed) # Return the fixed result\n}\n\n# Run the minimal example and save the result\nresult <- minimal_reprex()\n\n# Fix the full function\nprocess_data_fixed <- function(data, group_var, measure_var, do_transform = TRUE, min_count = 1) {\n  # Same function but with parameterized min_count and fixed filter\n  if (!is.data.frame(data) || !group_var %in% names(data) || !measure_var %in% names(data)) {\n    stop(\"Invalid inputs\")\n  }\n  \n  if (do_transform) {\n    data <- data %>%\n      mutate(across(where(is.numeric), ~ . + 100))\n  }\n  \n  result <- data %>%\n    group_by(across(all_of(group_var))) %>%\n    summarize(\n      mean_value = mean(!!sym(measure_var)),\n      count = n(),\n      .groups = \"drop\"\n    ) %>%\n    filter(count >= min_count) %>%  # Now parameterized\n    arrange(desc(mean_value))\n  \n  names(result) <- str_replace_all(names(result), \"_\", \".\")\n  \n  return(result)\n}\n\n# Test the fixed function\nresult_fixed <- process_data_fixed(test_data, \"group\", \"value\")\nprint(\"Result from fixed function:\")\nprint(result_fixed)  # Should show all groups A, B, and C\n```\n:::\n\n\n\n\n---\n\n## Part 2: Advanced  Topics and Best Practices\n\n---\n\n## Lesson 4: Advanced Debugging Techniques\n\nWhile the tools in Lesson 2 cover most day-to-day debugging, R offers more advanced techniques for complex scenarios, performance issues, and deeper inspection of R's object systems.\n\n### 1. Post-mortem Debugging with `recover()`\n\nThe `recover()` function is invaluable when an error occurs and you want to inspect the environment of each function in the call stack at the time of the error. It's like `browser()` but activated *after* an error.\n\nTo use it effectively, you can set it as the error handler globally:\n`options(error = recover)`\n\nWhen an error occurs, R will present a menu listing the function calls in the stack. You can select a number to enter the environment of that function call and inspect variables, just like in `browser()`.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Set recover as the error handler\noptions(error = recover)\n\n# Define a series of nested functions\nfunc_a <- function(x) {\n  func_b(x * 2)\n}\n\nfunc_b <- function(y) {\n  func_c(y + 5)\n}\n\nfunc_c <- function(z) {\n  if (z > 10) {\n    stop(\"Value too high in func_c!\")\n  }\n  return(z / 2)\n}\n\n# Trigger an error\n# func_a(3) # This will result in z = (3*2)+5 = 11, triggering the stop()\n\n# After the error, you'd see a menu like:\n# Enter a frame number, or 0 to exit\n#\n# 1: func_a(3)\n# 2: func_b(x * 2)\n# 3: func_c(y + 5)\n#\n# Selection:\n#\n# Typing '3' would take you into func_c's environment where you can inspect 'z'.\n# Typing 'ls()' would show objects in that frame.\n# Typing 'z' would show its value.\n# Typing '0' exits recover.\n\n# Don't forget to reset the error option if you don't want recover globally\n# options(error = NULL)\n```\n:::\n\n\n\n**When to use `recover()`:**\n*   When an unexpected error halts a long computation.\n*   When you need to understand the state of multiple functions in the call stack leading to an error.\n*   When `traceback()` isn't enough and you need interactive inspection.\n\n### 2. Profiling Code with `Rprof()` and `profvis`\n\nSometimes the \"bug\" isn't an error, but unexpectedly slow code. Profiling helps identify these performance bottlenecks.\n\n**a) `Rprof()`**\nR's built-in `Rprof()` function samples the call stack at regular intervals during code execution and writes the results to a file.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Start profiling, output to \"Rprof.out\"\nRprof(\"Rprof.out\")\n\n# Your potentially slow code here\nslow_function <- function() {\n  total <- 0\n  for (i in 1e5) {\n    total <- total + log(sqrt(i))\n  }\n  return(total)\n}\nresult <- slow_function()\n\n# Stop profiling\nRprof(NULL)\n\n# Analyze the output\nsummaryRprof(\"Rprof.out\")\n# This gives a summary of time spent in each function.\n```\n:::\n\n\n\nThe output of `summaryRprof()` can be a bit dense. It shows time spent in each function (\"self\" time) and time spent in that function plus functions it called (\"total\" time).\n\n**b) `profvis` Package**\nThe `profvis` package provides an interactive visualization of profiling data, making it much easier to understand.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# install.packages(\"profvis\") # If not already installed\nlibrary(profvis)\n\n# Profile an expression\nprofvis({\n  # Your potentially slow code here\n  slow_function <- function() {\n    total <- 0\n    for (i in 1e5) {\n      total <- total + log(sqrt(i)) # sqrt() is a bit redundant here with log()\n    }\n    return(total)\n  }\n  result <- slow_function()\n  \n  another_operation <- function(n) {\n    Sys.sleep(n) # Simulate some work\n  }\n  another_operation(0.5)\n})\n\n# This will open an interactive HTML widget in RStudio or your browser.\n# It shows a flame graph and data table, highlighting time-consuming calls.\n```\n:::\n\n\n\n`profvis` is highly recommended for a more intuitive understanding of where your code spends its time.\n\n### 3. Debugging S3 and S4 Methods\n\nR's object-oriented systems (S3 and S4) use generic functions and methods. Debugging them can be tricky because the actual code executed depends on the class of the object.\n\n**a) Finding Which Method is Called**\n*   `sloop::s3_dispatch()` or `sloop::s4_dispatch()`: These functions from the `sloop` package are excellent for seeing the method dispatch path.\n*   `methods()`: e.g., `methods(print)` shows all `print` methods. `methods(class = \"lm\")` shows all methods for `lm` objects.\n*   `getS3method()` / `getMethod()`: To retrieve the actual code of a specific method.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# install.packages(\"sloop\") # If not already installed\nlibrary(sloop)\n\n# S3 Example\ndata_frame <- data.frame(x = 1:3, y = letters[1:3])\ns3_dispatch(print(data_frame))\n# This will show:\n# => print.data.frame\n#  * print.default\n\n# Get the code for print.data.frame\n# getS3method(\"print\", \"data.frame\")\n\n# S4 Example (requires a class and generic with methods)\nsetClass(\"Person\", slots = c(name = \"character\", age = \"numeric\"))\nsetGeneric(\"display\", function(object) standardGeneric(\"display\"))\nsetMethod(\"display\", \"Person\", function(object) {\n  cat(\"Name:\", object@name, \", Age:\", object@age, \"\\\\n\")\n})\n\nalice <- new(\"Person\", name = \"Alice\", age = 30)\ns4_dispatch(display(alice))\n# => display,Person,ANY\n# Get the code for the method\n# getMethod(\"display\", \"Person\")\n```\n:::\n\n\n\n\n**b) Debugging a Specific Method**\nOnce you've identified the method, you can use `debug()` or `browser()` on it:\n*   `debug(getS3method(\"print\", \"data.frame\"))`\n*   Or, if it's your own S4 method, you can put `browser()` directly in its source code.\n\n### 4. Global Error Handling Options: `options(error = ...)`\n\nWe saw `options(error = recover)`. Another useful one is `options(error = dump.frames)`.\n*   `dump.frames` saves the call stack and environments to an object (default `last.dump`) when an error occurs.\n*   You can then use `debugger()` to perform post-mortem debugging on this dump.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Set dump.frames as the error handler\noptions(error = dump.frames)\n\n# Define a function that will cause an error\nerror_function <- function(a, b) {\n  a + b # This will error if b is a string\n}\n\n# Trigger an error\n# error_function(5, \"hello\")\n\n# Now, the dump is saved. You can inspect it:\n# debugger(last.dump)\n# This will start a browser-like session for the saved frames.\n\n# To list saved dumps:\n# ls(pattern = \".dump$\")\n\n# Reset error option\n# options(error = NULL)\n```\n:::\n\n\n\nThis is useful for non-interactive sessions (like batch scripts) where `recover` can't be used directly. You can save the dump and analyze it later.\n\n**Exercise 4.1: Using `recover()`**\n\n1.  Set `options(error = recover)`.\n2.  Write a function `calculate_ratio(a, b)` that returns `a / b`.\n3.  Inside `calculate_ratio`, add a check: if `b` is zero, `stop(\"Division by zero!\")`.\n4.  Call `calculate_ratio(10, 0)`.\n5.  When `recover` prompts you, enter the frame for `calculate_ratio`.\n6.  Inspect the values of `a` and `b`.\n7.  Exit `recover` and reset `options(error = NULL)`.\n\n\n\n\n::: {.cell exercise='ex4-1' solution_hidden='true'}\n```{webr}\n#| exercise: ex4-1\n#| solution_hidden: true\n\n# Solution for Exercise 4.1 (conceptual, as recover is interactive)\n# options(error = recover) # Step 1\n\ncalculate_ratio <- function(a, b) { # Step 2\n  if (b == 0) { # Step 3\n    stop(\"Division by zero!\")\n  }\n  return(a / b)\n}\n\n# calculate_ratio(10, 0) # Step 4\n# At this point, recover() would activate.\n# User would select the frame for calculate_ratio.\n# Then inspect 'a' (shows 10) and 'b' (shows 0).\n# Then exit recover.\n\n# options(error = NULL) # Step 7\n\nprint(\"Exercise 4.1: Conceptual steps for using recover() described above.\")\nprint(\"To run interactively: uncomment options() and the function call, then run in an R console.\")\n```\n:::\n\n\n\n\n**Exercise 4.2: Profiling with `profvis`**\n\n1.  Create a function `generate_data(n_rows, n_cols)` that creates a data frame with `n_rows` and `n_cols`. Each cell should be a random number `runif(1)`.\n2.  Create another function `process_data(df)` that:\n    *   Calculates the mean of each column.\n    *   Calculates the sum of each row.\n    *   Does this in a loop 10 times (just to make it take a bit longer).\n3.  Use `profvis` to profile calling `generate_data(1000, 100)` and then passing its result to `process_data()`.\n4.  Identify which parts of your functions take the most time.\n\n\n\n\n::: {.cell exercise='ex4-2' solution_hidden='true'}\n```{webr}\n#| exercise: ex4-2\n#| solution_hidden: true\n# library(profvis) # Not available in webr environment for direct execution\n\n# Solution for Exercise 4.2 (conceptual for profvis)\ngenerate_data <- function(n_rows, n_cols) {\n  Sys.sleep(0.1) # Simulate some work\n  matrix_data <- matrix(runif(n_rows * n_cols), nrow = n_rows, ncol = n_cols)\n  df <- as.data.frame(matrix_data)\n  return(df)\n}\n\nprocess_data <- function(df) {\n  col_means_list <- list()\n  row_sums_list <- list()\n  for (i in 1:10) { # Loop to make it take longer\n    Sys.sleep(0.05) # Simulate work\n    col_means_list[[i]] <- colMeans(df, na.rm = TRUE)\n    row_sums_list[[i]] <- rowSums(df, na.rm = TRUE)\n  }\n  return(list(col_means = col_means_list, row_sums = row_sums_list))\n}\n\n# Conceptual profvis usage:\n# profvis({\n#   my_data <- generate_data(1000, 100)\n#   processed_results <- process_data(my_data)\n# })\n\nprint(\"Exercise 4.2: Functions defined. Use profvis in a local R environment to see the profile.\")\nprint(\"Simulated work with Sys.sleep() added for demonstration.\")\n\n# Example of running without profvis for webr\nmy_data_ex4_2 <- generate_data(100, 10) # Smaller for webr\nprocessed_results_ex4_2 <- process_data(my_data_ex4_2)\nprint(\"Sample run completed (without actual profiling display).\")\n```\n:::\n\n\n\n\n---\n\n## Part 3: Specialized Debugging and Best Practices\n\n---\n\n## Lesson 5: Debugging in Specific Contexts\n\nDebugging challenges can vary significantly depending on the R environment or framework you're working with. This lesson explores common issues and tailored strategies for Shiny applications, R Markdown/Quarto documents, and custom R packages.\n\n### 1. Debugging Shiny Applications\n\nShiny apps introduce reactivity, which can make debugging less straightforward. Errors might stem from server logic, UI definitions, or the interaction between them.\n\n**Common Issues:**\n*   **Reactivity Problems:** Outputs not updating, observers firing unexpectedly, or infinite reactive loops.\n*   **Server/UI Disconnects:** UI elements not correctly linked to server-side logic or vice-versa.\n*   **Slow Performance:** Bottlenecks in reactive expressions or data processing.\n*   **Silent Errors:** Errors within reactive expressions might not always stop the app but can lead to incorrect behavior.\n\n**Debugging Tools & Techniques:**\n*   **`browser()` in Server Logic:** Place `browser()` inside `reactive()` expressions, `observeEvent()`, or `renderPlot()` functions to inspect values and flow at specific points.\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    # server.R or app.R (server part)\n    server <- function(input, output) {\n      data_reactive <- reactive({\n        # browser() # Uncomment to debug this reactive expression\n        req(input$my_slider)\n        data_frame <- data.frame(x = 1:input$my_slider, y = rnorm(input$my_slider))\n        # print(head(data_frame)) # Useful for quick checks\n        return(data_frame)\n      })\n    \n      output$my_plot <- renderPlot({\n        df <- data_reactive()\n        # browser() # Uncomment to inspect df before plotting\n        plot(df$x, df$y)\n      })\n    }\n    ```\n    :::\n\n\n\n*   **`print()` Statements:** Use `print()` or `cat()` within reactive expressions to output values to the R console. Remember that these will execute every time the reactive expression re-evaluates.\n*   **`isolate()`:** Use `isolate()` to read a reactive value without creating a dependency, which can help pinpoint unnecessary re-evaluations.\n*   **`shiny::reactiveLog()` and `reactlog` package:** These tools provide a visual representation of the reactive graph and its execution, helping to understand dependencies and data flow. `reactlog::reactlog_show()` or `shiny::showReactLog()` can be very insightful.\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    # At the top of your app.R or global.R\n    # options(shiny.reactlog = TRUE) # For built-in reactive log\n    \n    # Or using the reactlog package (recommended)\n    # install.packages(\"reactlog\")\n    # library(reactlog)\n    # reactlog_enable()\n    \n    # After running the app and interacting with it:\n    # reactlog_show() # Opens the visualization\n    ```\n    :::\n\n\n\n*   **Shiny's Built-in Debugging Aids:** Shiny often prints useful information to the R console, including error messages that might not be visible in the app's UI.\n*   **RStudio's Shiny Debugging Tools:** RStudio provides features like direct inspection of reactive values when the app is running.\n\n**Tips for Debugging Shiny Apps:**\n*   **Isolate Components:** Test reactive expressions or modules individually if possible.\n*   **Simplify:** If an app is complex, try to reproduce the issue in a minimal version.\n*   **Check Inputs:** Ensure `input` values are what you expect (e.g., correct type, not NULL when `req()` is needed).\n\n### 2. Debugging R Markdown and Quarto Documents\n\nWhen knitting R Markdown (`.Rmd`) or rendering Quarto (`.qmd`) documents, errors often occur within code chunks.\n\n**Common Issues:**\n*   **Code Chunk Errors:** An R error in a specific chunk stops the rendering process.\n*   **Environment Conflicts:** Variables or functions defined in one chunk might not be available or might be overwritten in another, depending on chunk options.\n*   **Rendering Problems:** Issues with output formats (HTML, PDF, Word), especially with LaTeX for PDF output.\n*   **Package/Dependency Issues:** A required package might not be installed or loaded in the environment where the document is rendered.\n\n**Debugging Tools & Techniques:**\n*   **Run Chunks Individually:** Execute code chunks one by one within RStudio (or your IDE) to pinpoint where an error occurs.\n*   **Chunk Option `error = TRUE`:** `knitr::opts_chunk$set(error = TRUE)` (globally) or ````{r error=TRUE}` (for a specific chunk) will allow the document to render even if a chunk has an error, printing the error message in the output. This is useful for identifying multiple errors at once.\n*   **Chunk Option `debug = TRUE`:** ````{r debug=TRUE}` (for a specific chunk) can sometimes provide more detailed debugging information or invoke a debugger, though its behavior can vary.\n*   **Inspect Intermediate Files:** For complex issues, especially with PDF output, inspect the intermediate `.md` or `.tex` files generated by `knitr` or Quarto. This can reveal formatting or LaTeX-specific errors.\n    *   Use `keep_md: true` or `keep_tex: true` in the YAML header.\n*   **Simplify the Document:** Comment out sections or chunks to isolate the problematic part.\n*   **Check `sessionInfo()`:** Ensure that the R session rendering the document has all necessary packages at the correct versions.\n\n**Tips for Debugging `.Rmd`/`.qmd` Files:**\n*   **Chunk Labels:** Always use unique and descriptive labels for your code chunks.\n*   **Cache with Caution:** While caching (`cache = TRUE`) speeds up rendering, it can sometimes hide issues or use stale results. Clear the cache if you suspect problems.\n*   **Small, Focused Chunks:** Break down long computations into smaller, more manageable chunks.\n\n### 3. Debugging Custom R Packages\n\nDeveloping R packages introduces its own set of debugging challenges, often related to namespaces, documentation, or the build/check process.\n\n**Common Issues:**\n*   **Namespace Errors:** Functions not being exported or imported correctly (`Error: object 'X' not found` when it should be available).\n*   **Documentation Mismatches:** Discrepancies between function arguments in code and in `.Rd` files (often caught by `R CMD check`).\n*   **Failing `R CMD check`:** Various warnings or errors related to coding standards, examples, tests, or vignette building.\n*   **Test Failures:** Unit tests in `tests/testthat/` not passing.\n\n**Debugging Tools & Techniques:**\n*   **`devtools::load_all()` (or `pkgload::load_all()`):** This is the most crucial tool. It simulates package installation and loading, making all exported and internal functions available for interactive testing in the console. Use it frequently during development.\n*   **`devtools::check()`:** Runs `R CMD check`, which performs a comprehensive suite of checks on your package. Address all errors, warnings, and notes.\n*   **`devtools::test()` (or `testthat::test_local()`):** Runs your unit tests. Use `browser()` within your test files or the functions being tested to debug failures.\n*   **RStudio's Build Pane:** Provides convenient buttons for `Load All`, `Test Package`, and `Check Package`.\n*   **`browser()` in Package Functions:** You can place `browser()` directly into your package's R functions. After `devtools::load_all()`, calling the function will trigger the debugger.\n*   **Debugging Exported vs. Internal Functions:** Remember that internal functions (not exported) are accessed with `packageName:::functionName`, while exported ones are `packageName::functionName` or directly after `library(packageName)`.\n\n**Tips for Debugging Packages:**\n*   **Iterative Development:** `Load All` and test small changes frequently.\n*   **Read `R CMD check` Output Carefully:** The messages, even notes, often point to important issues or best practices.\n*   **Use `roxygen2`:** For generating documentation and managing the `NAMESPACE` file. This reduces manual errors.\n*   **Write Comprehensive Unit Tests:** Good tests are your first line of defense and a great debugging aid.\n\n**Exercise 5.1: Debugging a (Conceptual) Shiny App**\n\nImagine a Shiny app with an input `sliderInput(\"num\", \"Choose a number\", 1, 10, 5)` and an output that should display `input$num * 2`. The output is not updating.\n\n1.  Where would you first place `browser()` or `print()` statements to investigate?\n2.  What are possible reasons for the output not updating?\n\n\n\n\n::: {.cell exercise='ex5-1' solution_hidden='true'}\n```{webr}\n#| exercise: ex5-1\n#| solution_hidden: true\n\n# Conceptual Solution for Exercise 5.1\n\n# 1. Where to place browser() or print():\n#    - Inside the reactive expression that calculates `input$num * 2`.\n#    - Inside the render function for the output that displays the result.\n#    Example:\n#    server <- function(input, output) {\n#      output$doubled_value <- renderText({\n#        current_num <- input$num\n#        print(paste(\"Slider value:\", current_num)) # Print statement\n#        # browser() # Or browser()\n#        result <- current_num * 2\n#        print(paste(\"Result:\", result))\n#        return(result)\n#      })\n#    }\n\n# 2. Possible reasons for the output not updating:\n#    - The output UI element is not correctly defined or named.\n#    - The `renderText` (or similar) function is not correctly assigned to `output$doubled_value`.\n#    - The reactive expression is not actually re-evaluating (e.g., `input$num` is not being read reactively).\n#    - An error is occurring silently within the reactive expression before the new value is returned.\n#    - The UI is not correctly displaying the output (e.g., wrong output function used in UI like `textOutput` vs `verbatimTextOutput`).\n\nprint(\"Exercise 5.1: Conceptual debugging steps for a Shiny app described above.\")\n```\n:::\n\n\n\n\n**Exercise 5.2: Debugging an R Markdown Chunk**\n\nAn R Markdown document has a chunk that loads data and then tries to plot it. The plot is not appearing, and knitting stops with an error \"object 'my_data' not found\" in the plotting chunk.\n\n1.  What is the most likely cause related to chunk execution order or environment?\n2.  How would you verify this and fix it?\n\n\n\n\n::: {.cell exercise='ex5-2' solution_hidden='true'}\n```{webr}\n#| exercise: ex5-2\n#| solution_hidden: true\n\n# Conceptual Solution for Exercise 5.2\n\n# 1. Most likely cause:\n#    - The chunk that loads `my_data` was not executed before the chunk that tries to plot `my_data`.\n#    - The chunk loading `my_data` might have an error itself, preventing `my_data` from being created.\n#    - `my_data` was created in a chunk, but then removed or modified before the plotting chunk (less likely for simple \"not found\").\n#    - Chunk options like `eval=FALSE` on the data loading chunk, or a different `engine` that doesn't share the R environment.\n\n# 2. How to verify and fix:\n#    - **Verify:**\n#      - Run the data loading chunk manually in the R console or RStudio.\n#      - Check if `my_data` exists in the environment after running the loading chunk (`ls()`, `exists(\"my_data\")`).\n#      - Check for any error messages when running the data loading chunk.\n#      - Ensure the plotting chunk comes *after* the data loading chunk in the document.\n#    - **Fix:**\n#      - Ensure the data loading chunk is correctly written and executes without errors before the plotting chunk.\n#      - Make sure `eval=TRUE` (which is default) for the data loading chunk.\n#      - If using RStudio, try \"Run All Chunks Above\" for the plotting chunk.\n\nprint(\"Exercise 5.2: Conceptual debugging steps for an R Markdown document described above.\")\n```\n:::\n\n\n\n\n---\n\n## Lesson 6: Preventative Measures and Writing Debuggable Code\n\nWhile knowing how to debug is crucial, writing code that is less prone to bugs and easier to debug in the first place can save significant time and effort. This lesson focuses on proactive strategies.\n\n### 1. Unit Testing with `testthat`\n\nUnit tests are small pieces of code that verify that individual functions (units) of your code work as expected. The `testthat` package is the standard for unit testing in R.\n\n**Importance of Unit Tests:**\n*   **Catch Bugs Early:** Detect regressions (when new changes break existing functionality) immediately.\n*   **Facilitate Refactoring:** Allow you to change code internals with confidence, as long as tests still pass.\n*   **Serve as Documentation:** Tests demonstrate how your functions are intended to be used and what their expected outputs are.\n*   **Improve Code Design:** Thinking about how to test a function often leads to better, more modular design.\n\n**Basic Structure of `testthat` Tests:**\nTests are typically organized in files within the `tests/testthat/` directory of a package (e.g., `tests/testthat/test-my_function.R`).\n\n*   **`test_that(\"description of what is being tested\", { ... })`:** Defines a block of related tests.\n*   **Expectation Functions (`expect_*`)**: These functions make assertions about your code.\n    *   `expect_equal(object, expected_value)`: Checks for exact equality (for numbers, considers tolerance).\n    *   `expect_identical(object, expected_value)`: Checks for exact, bit-for-bit equality.\n    *   `expect_true(condition)`, `expect_false(condition)`: Checks if a condition is TRUE or FALSE.\n    *   `expect_error(expression_that_should_error, regexp_for_error_message)`: Checks if code throws an error.\n    *   `expect_warning(...)`, `expect_message(...)`, `expect_output(...)`.\n    *   `expect_s3_class(object, \"class_name\")`, `expect_s4_class(...)`.\n    *   And many more!\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Example: tests/testthat/test-addition.R\n\n# Source the function to be tested (if not in a package being loaded via devtools)\n# source(\"../../R/addition.R\") # Assuming your function is in R/addition.R\n\n# A simple function to test\nadd_numbers <- function(x, y) {\n  if (!is.numeric(x) || !is.numeric(y)) {\n    stop(\"Inputs must be numeric\")\n  }\n  return(x + y)\n}\n\nlibrary(testthat)\n\ntest_that(\"add_numbers works with positive integers\", {\n  expect_equal(add_numbers(2, 3), 5)\n  expect_equal(add_numbers(100, 200), 300)\n})\n\ntest_that(\"add_numbers works with zero and negative numbers\", {\n  expect_equal(add_numbers(0, 5), 5)\n  expect_equal(add_numbers(-5, 5), 0)\n  expect_equal(add_numbers(-5, -5), -10)\n})\n\ntest_that(\"add_numbers handles non-numeric input\", {\n  expect_error(add_numbers(\"a\", 5), \"Inputs must be numeric\")\n  expect_error(add_numbers(5, \"b\"), \"Inputs must be numeric\")\n})\n\n# To run tests for a package:\n# devtools::test()\n\n# To run a specific test file:\n# testthat::test_file(\"tests/testthat/test-addition.R\")\n```\n:::\n\n\n\n\n**Running Tests:**\n*   For packages: `devtools::test()` or RStudio's Build pane.\n*   For individual files: `testthat::test_file(\"path/to/test-file.R\")`.\n\n### 2. Defensive Programming\n\nDefensive programming involves writing code that anticipates potential problems and handles them gracefully, rather than assuming inputs and states will always be perfect.\n\n**Techniques:**\n*   **Assertions (`stopifnot()`):**\n    `stopifnot()` checks if its arguments are all TRUE. If not, it throws an error. It's good for preconditions at the beginning of a function.\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    calculate_mean_positive <- function(vec) {\n      stopifnot(is.numeric(vec), length(vec) > 0, all(vec > 0))\n      mean(vec)\n    }\n    \n    # calculate_mean_positive(c(1, 2, -3)) # This will error due to all(vec > 0) being false\n    # calculate_mean_positive(c())       # This will error due to length(vec) > 0 being false\n    print(calculate_mean_positive(c(1, 2, 3))) # This works\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] 2\n    ```\n    \n    \n    :::\n    :::\n\n\n\n*   **Input Validation (Checking Arguments):**\n    Explicitly check function arguments for type, class, length, range, etc., and provide informative error messages if they are invalid.\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    create_greeting <- function(name, language = \"en\") {\n      if (!is.character(name) || length(name) != 1) {\n        stop(\"`name` must be a single string.\", call. = FALSE)\n      }\n      if (!language %in% c(\"en\", \"es\")) {\n        stop(\"`language` must be 'en' or 'es'.\", call. = FALSE)\n      }\n      \n      if (language == \"en\") paste(\"Hello,\", name)\n      else paste(\"Hola,\", name)\n    }\n    print(create_greeting(\"Alice\"))\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] \"Hello, Alice\"\n    ```\n    \n    \n    :::\n    \n    ```{.r .cell-code}\n    # print(create_greeting(\"Bob\", \"fr\")) # Errors\n    ```\n    :::\n\n\n\n    The `assertthat` package provides more expressive assertion functions (e.g., `assert_that(is.number(x))`).\n*   **Graceful Failure:** Instead of just erroring, sometimes functions can return a specific value (e.g., `NA`, `NULL`, an empty data frame) or issue a warning for non-critical issues.\n*   **Clear Error Messages:** Make error messages informative. Tell the user *what* went wrong, *why*, and potentially *how to fix it*.\n\n### 3. Code Style and Readability\n\nReadable code is easier to understand, maintain, and debug (by yourself and others).\n\n**Key Principles:**\n*   **Consistent Style:** Follow a style guide (e.g., the [tidyverse style guide](https://style.tidyverse.org/)). Use linters (like the `lintr` package) to check and enforce style.\n*   **Meaningful Names:** Choose descriptive names for variables, functions, and arguments. Avoid overly short or cryptic names.\n    *   Good: `calculate_average_income`, `customer_data`\n    *   Less good: `avginc`, `df1`\n*   **Effective Commenting:** Comments should explain the \"why\" (the intent or logic), not just the \"what\" (which should be clear from the code itself). Comment complex sections or non-obvious logic.\n*   **Modularity (Small Functions):** Break down complex tasks into smaller, single-purpose functions. Each function should do one thing well. This makes them easier to test and debug.\n*   **Limit Side Effects:** Functions are easiest to reason about when they don't modify objects outside their own environment (i.e., they don't have side effects). Prefer functions that take inputs and return outputs.\n*   **DRY (Don't Repeat Yourself):** If you find yourself copying and pasting code, consider writing a function instead.\n*   **Whitespace:** Use whitespace (blank lines, indentation) to structure code visually and improve readability.\n\n**Exercise 6.1: Writing a `testthat` Test**\n\nGiven the following function:\n`trim_vector <- function(x, n = 1) { x[(n+1):(length(x)-n)] }`\n\n1.  Write at least two `test_that()` blocks for this function.\n2.  Include tests for valid inputs and edge cases (e.g., what if `n` is too large? What if `x` is short?).\n\n\n\n\n::: {.cell exercise='ex6-1' solution_hidden='true'}\n```{webr}\n#| exercise: ex6-1\n#| solution_hidden: true\n\ntrim_vector <- function(x, n = 1) {\n  if (n < 0) stop(\"`n` must be non-negative\")\n  len_x <- length(x)\n  start_index <- n + 1\n  end_index <- len_x - n\n  if (start_index > end_index + 1) { # Allows empty vector if n is large enough to trim everything\n      return(x[0]) # Return empty vector of same type\n  }\n  return(x[start_index:end_index])\n}\n\ntest_that(\"trim_vector works with basic valid inputs\", {\n  expect_equal(trim_vector(1:10, n = 1), 2:9)\n  expect_equal(trim_vector(letters[1:5], n = 2), letters[3])\n  expect_equal(trim_vector(c(TRUE, FALSE, TRUE, FALSE), n = 0), c(TRUE, FALSE, TRUE, FALSE))\n})\n\ntest_that(\"trim_vector handles edge cases\", {\n  expect_equal(trim_vector(1:5, n = 2), 3) # Trims to a single element\n  expect_equal(length(trim_vector(1:5, n = 3)), 0) # n is large, results in empty vector\n  expect_equal(length(trim_vector(1:2, n = 1)), 0) # Trims everything\n  expect_equal(trim_vector(c(), n = 1), c()) # Empty input\n  expect_error(trim_vector(1:5, n = -1)) # Invalid n\n})\n\nprint(\"Exercise 6.1: testthat tests for trim_vector defined and conceptually run.\")\n```\n:::\n\n\n\n\n**Exercise 6.2: Improving Code Readability**\n\nConsider this poorly written function:\n`f <- function(d, c1, c2, v) { d_s <- d[d[[c1]] > v, ]; aggregate(d_s[[c2]] ~ d_s[[c1]], FUN=mean) }`\n\n1.  Rewrite this function with more descriptive names and better formatting.\n2.  Add comments explaining its purpose and arguments.\n3.  Add basic input validation.\n\n\n\n\n::: {.cell exercise='ex6-2' solution_hidden='true'}\n```{webr}\n#| exercise: ex6-2\n#| solution_hidden: true\n\n# Original function:\n# f <- function(d, c1, c2, v) { d_s <- d[d[[c1]] > v, ]; aggregate(d_s[[c2]] ~ d_s[[c1]], FUN=mean) }\n\n# Rewritten function:\ncalculate_mean_by_group_filtered <- function(data, group_col_name, value_col_name, filter_threshold) {\n  # Calculates the mean of 'value_col_name' for each group in 'group_col_name',\n  # after filtering 'data' where 'group_col_name' is greater than 'filter_threshold'.\n  # \n  # Args:\n  #   data: A data frame.\n  #   group_col_name: Character string, name of the column to group by and filter on.\n  #   value_col_name: Character string, name of the column to calculate the mean from.\n  #   filter_threshold: Numeric, the value to filter 'group_col_name' by (rows kept if > threshold).\n  #\n  # Returns:\n  #   A data frame with group means, or NULL if inputs are invalid.\n\n  # Input validation\n  if (!is.data.frame(data)) {\n    stop(\"Input 'data' must be a data frame.\")\n  }\n  if (!is.character(group_col_name) || length(group_col_name) != 1 || !group_col_name %in% names(data)) {\n    stop(\"'group_col_name' must be a valid column name in 'data'.\")\n  }\n  if (!is.character(value_col_name) || length(value_col_name) != 1 || !value_col_name %in% names(data)) {\n    stop(\"'value_col_name' must be a valid column name in 'data'.\")\n  }\n  if (!is.numeric(data[[group_col_name]])) {\n    stop(paste(\"Column '\", group_col_name, \"' must be numeric for filtering.\", sep=\"\"))\n  }\n   if (!is.numeric(data[[value_col_name]])) {\n    stop(paste(\"Column '\", value_col_name, \"' must be numeric for calculating mean.\", sep=\"\"))\n  }\n  if (!is.numeric(filter_threshold) || length(filter_threshold) != 1) {\n    stop(\"'filter_threshold' must be a single numeric value.\")\n  }\n\n  # Filter the data: keep rows where the group_col_name value is greater than filter_threshold\n  subset_data <- data[data[[group_col_name]] > filter_threshold, ]\n\n  if (nrow(subset_data) == 0) {\n    warning(\"No data remains after filtering. Returning empty result.\")\n    # Create an empty data frame with expected column names\n    # The names will be group_col_name and value_col_name (or similar depending on aggregate)\n    # For simplicity, returning NULL or an empty named list might also be an option.\n    # Here, we try to match aggregate's typical output structure for consistency.\n    empty_df <- data.frame(matrix(ncol = 2, nrow = 0))\n    names(empty_df) <- c(group_col_name, value_col_name) # Adjust if aggregate names differently\n    return(empty_df)\n  }\n\n  # Construct the formula for aggregation dynamically\n  # e.g., value_column ~ group_column\n  formula_str <- paste(value_col_name, \"~\", group_col_name)\n  agg_formula <- as.formula(formula_str)\n  \n  # Aggregate to find the mean of value_col_name for each group in group_col_name\n  # The result of aggregate will have columns named after group_col_name and value_col_name (or x)\n  aggregated_results <- aggregate(agg_formula, data = subset_data, FUN = mean)\n  \n  return(aggregated_results)\n}\n\n# Example Usage (conceptual, as it depends on data)\n# test_df_ex6_2 <- data.frame(\n#   category = c(10, 20, 10, 30, 20, 30),\n#   amount = c(100, 150, 120, 200, 180, 220),\n#   other_col = letters[1:6]\n# )\n# result_ex6_2 <- calculate_mean_by_group_filtered(test_df_ex6_2, \"category\", \"amount\", 15)\n# print(result_ex6_2)\n\nprint(\"Exercise 6.2: Rewritten function 'calculate_mean_by_group_filtered' defined.\")\n```\n:::\n\n\n\n\n---\n\n## Course Conclusion\n\nCongratulations on completing the Troubleshooting and Debugging in R course! \n\nThroughout these lessons, you've learned to:\n*   Interpret R's error messages effectively.\n*   Utilize a range of built-in debugging tools like `browser()`, `traceback()`, `tryCatch()`.\n*   Apply systematic approaches to isolate and resolve bugs.\n*   Leverage advanced techniques such as `recover()` for post-mortem debugging and `profvis` for performance profiling.\n*   Adapt your debugging strategies for specific contexts like Shiny, R Markdown/Quarto, and package development.\n*   Embrace preventative measures, including writing unit tests with `testthat`, practicing defensive programming, and maintaining a clean, readable code style.\n\nDebugging is a skill honed through practice. The more you encounter and solve errors, the more proficient you'll become. Remember to be patient, methodical, and don't hesitate to use the tools and techniques covered here.\n\nHappy coding, and may your bugs be few and easy to find!\n\n---\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}