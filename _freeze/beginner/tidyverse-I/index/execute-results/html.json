{
  "hash": "bc3c95edf6cdee705db138cd830084fb",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Tidyverse: I\"\nauthor: \"David Munoz Tord\"\ndescription: \"Learn the tidyverse superpowers for data manipulation and transformation\"\nengine: knitr\ndate: \"05/05/2025\"\nformat: live-html\n---\n\n::: {.cell}\n\n:::\n\n\n\n\n## Introduction: Welcome to the Tidyverse!\n\nImagine you're a data wizard with a magic wand. The tidyverse is your spellbook, and each package is a different magical incantation you can use to transform and manipulate data! ðŸ§™â€â™‚ï¸âœ¨\n\n```r\n# Load the tidyverse - it's like summoning ALL your magic powers at once!\nlibrary(tidyverse)\n```\n\nThe tidyverse is a collection of R packages that share a common philosophy and are designed to work together harmoniously. Think of it as the Avengers of data science - each package has its own superpower, but together they're unstoppable!\n\n### The Core Tidyverse Packages\n\n```r\n# The main tidyverse packages - your magical toolkit\nlibrary(dplyr)    # Data manipulation - like having telekinesis for data!\nlibrary(ggplot2)  # Data visualization - painting with data!\nlibrary(tidyr)    # Data tidying - Marie Kondo for your datasets!\nlibrary(readr)    # Data import - your portal to other data dimensions!\nlibrary(purrr)    # Functional programming - clone yourself to do multiple tasks!\nlibrary(tibble)   # Modern dataframes - your magical workbench!\nlibrary(stringr)  # String manipulation - speak the language of text!\nlibrary(forcats)  # Factor handling - taming wild categorical variables!\n```\n\n### The Magic Pipe: %>%\n\nThe pipe operator `%>%` is like your magic wand - it allows you to chain spells together in a logical sequence! It takes the output from one function and feeds it as the input to the next function.\n\n```r\n# Without the pipe - nested spells that are hard to read\nround(mean(c(1, 2, 3, NA), na.rm = TRUE), digits = 2)\n\n# With the pipe - a clear sequence of magical steps\nc(1, 2, 3, NA) %>% \n  mean(na.rm = TRUE) %>%\n  round(digits = 2)\n```\n\nðŸ’¡ **Pro Tip**: You can use the keyboard shortcut <kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>M</kbd> (Windows) or <kbd>Cmd</kbd>+<kbd>Shift</kbd>+<kbd>M</kbd> (Mac) to insert the pipe.\n\n### Package Name Prefixes\n\nWhen casting spells, sometimes you need to be specific about which spellbook you're using:\n\n```r\n# Different packages may have functions with the same name\nstats::filter() # Time series filtering\ndplyr::filter() # Row filtering for dataframes\n\n# Each tidyverse package has consistent prefixes\nreadr::read_csv()   # Reading CSV files\nreadr::write_csv()  # Writing CSV files\nstringr::str_detect() # String detection\nforcats::fct_relevel() # Factor releveling\n```\n\n### Exercise 1: Your First Tidyverse Spell\n\nLet's start with a simple spell - creating and exploring a tibble:\n\n\n\n::: {.cell exercise='ex_intro_1'}\n```{webr}\n#| exercise: ex_intro_1\n\n```\n:::\n\n\n\n::: { .hint exercise=\"ex_intro_1\"}\n::: { .callout-note collapse=\"false\"}\n## Hint\nUse `tibble()` to create a magical data table, then try exploring it with `glimpse()`. It's like having X-ray vision for your data!\n:::\n:::\n\n::: { .solution exercise=\"ex_intro_1\" }\n::: { .callout-tip collapse=\"false\"}\n## Solution:\n```r\n# Load the tidyverse spellbook\nlibrary(tidyverse)\n\n# Create a magical creature dataset\nmagical_creatures <- tibble(\n  creature = c(\"Dragon\", \"Unicorn\", \"Phoenix\", \"Griffin\", \"Mermaid\"),\n  magic_power = c(95, 80, 90, 75, 60),\n  habitat = c(\"Mountains\", \"Forest\", \"Volcano\", \"Sky\", \"Ocean\"),\n  lifespan = c(1000, 500, 1500, 300, 200)\n)\n\n# Look at our magical dataset\nmagical_creatures\n\n# Use the glimpse spell to see through its structure\nglimpse(magical_creatures)\n\n# Check the data type - it's a tibble, not a plain dataframe!\nclass(magical_creatures)\n\n# Use the pipe to chain operations\nmagical_creatures %>%\n  filter(magic_power > 70) %>%\n  arrange(desc(lifespan))\n```\n:::\n:::\n\n## Tibbles: The Modern Data Workbench\n\nTibbles are modern reimagined dataframes - they're like regular dataframes but with superpowers! They don't change variable names or types, they don't create row names, and they make printing large datasets much more pleasant.\n\n### Why Use Tibbles?\n\nRegular dataframes have some quirks that tibbles fix:\n- They don't automatically convert strings to factors\n- They don't mangle variable names\n- They show only the first 10 rows and all columns that fit on screen\n- They have consistent subsetting behavior\n- They give you better error messages\n\n```r\n# Create a tibble from scratch - building your workbench!\nwizards <- tibble(\n  name = c(\"Gandalf\", \"Dumbledore\", \"Merlin\", \"Dr. Strange\"),\n  specialty = c(\"Fireworks\", \"Transfiguration\", \"Time Magic\", \"Reality Warping\"),\n  power_level = c(95, 90, 99, 85)\n)\n\n# Convert existing dataframe to tibble - upgrade your workbench!\ndata(mtcars)\nmtcars_tibble <- as_tibble(mtcars, rownames = \"car_model\")\n\n# Creating a tibble row-by-row (like SAS CARDS/DATALINES)\nspells <- tribble(\n  ~spell_name,    ~power, ~element,    ~casting_time,\n  \"Fireball\",       80,   \"Fire\",       3,\n  \"Ice Lance\",      65,   \"Water\",      1,\n  \"Earthquake\",     90,   \"Earth\",      5,\n  \"Lightning Bolt\", 75,   \"Air\",        2\n)\nspells\n```\n\n### Tibble Subsetting\n\nTibbles maintain consistent output types, which helps prevent errors in your code:\n\n```r\n# Single bracket [ ] always returns a tibble\nwizards[\"name\"]        # Still a tibble with 1 column\nwizards[1:2, \"name\"]   # Still a tibble with 1 column\n\n# Double bracket [[ ]] or $ extracts a single column as a vector\nwizards[[\"name\"]]      # Character vector\nwizards$name           # Character vector\n```\n\n### Exercise 2: Tibble Transformation\n\nTransform this plain old dataframe into a shiny new tibble:\n\n\n\n::: {.cell exercise='ex_tibbles_1'}\n```{webr}\n#| exercise: ex_tibbles_1\n\n```\n:::\n\n\n\n::: { .hint exercise=\"ex_tibbles_1\"}\n::: { .callout-note collapse=\"false\"}\n## Hint\nUse `as_tibble()` to convert a dataframe to a tibble. For extra magic, use `rownames_to_column()` to preserve row names!\n:::\n:::\n\n::: { .solution exercise=\"ex_tibbles_1\" }\n::: { .callout-tip collapse=\"false\"}\n## Solution:\n```r\n# Load the tidyverse\nlibrary(tidyverse)\n\n# Create a regular dataframe - the old rusty workbench\ndata(iris)\nhead(iris)\n\n# Convert to tibble with as_tibble()\niris_tibble <- as_tibble(iris)\niris_tibble\n\n# Another way - if your dataframe has rownames you want to keep\ndata(mtcars)\nmtcars_tibble <- as_tibble(mtcars, rownames = \"car_model\")\n\n# Or using rownames_to_column()\nmtcars_tibble2 <- mtcars %>% \n  rownames_to_column(\"car_model\") %>%\n  as_tibble()\n\n# Print to see the difference\nmtcars_tibble\n\n# Create a tibble from scratch with tribble\npotion_ingredients <- tribble(\n  ~potion,         ~ingredient,        ~amount, ~unit,\n  \"Health Potion\", \"Red Mushroom\",     3,       \"pieces\",\n  \"Health Potion\", \"Spring Water\",     100,     \"ml\",\n  \"Mana Potion\",   \"Blue Flower\",      2,       \"pieces\",\n  \"Mana Potion\",   \"Moon Water\",       100,     \"ml\",\n  \"Strength Potion\",\"Dragon Scale\",    1,       \"piece\",\n  \"Strength Potion\",\"Volcano Ash\",     50,      \"g\"\n)\npotion_ingredients\n```\n:::\n:::\n\n## Data Import & Export: Opening Portals to Other Dimensions\n\nThe tidyverse makes it super easy to import and export data from various file formats. It's like having a magical portal that connects to many different data dimensions!\n\n### Reading Data with readr\n\nThe readr package provides a fast and friendly way to read rectangular data files:\n\n```r\n# Reading data - opening a portal!\n# CSV files\nmy_data <- read_csv(\"data.csv\")\n\n# TSV files\nmy_tsv_data <- read_tsv(\"data.tsv\")\n\n# Fixed width files\nmy_fixed_data <- read_fwf(\"data.txt\", \n                         col_positions = fwf_widths(c(10, 5, 8)))\n\n# Delimited files with any delimiter\nmy_delim_data <- read_delim(\"data.txt\", delim = \"|\")\n```\n\n### Controlling Column Types\n\nYou can specify the types of columns you're reading to ensure your data comes through the portal correctly:\n\n```r\n# Specify column types\npotions_data <- read_csv(\"potions.csv\",\n  col_types = cols(\n    name = col_character(),\n    power = col_double(),\n    ingredients = col_integer(),\n    is_legendary = col_logical(),\n    discovery_date = col_date(format = \"%Y-%m-%d\")\n  )\n)\n\n# Preview the column specification without reading the file\nspec_csv(\"potions.csv\")\n```\n\n### Writing Data\n\nSending your magical creations to other dimensions is just as easy:\n\n```r\n# Writing data\nwrite_csv(my_data, \"new_data.csv\")\nwrite_tsv(my_data, \"new_data.tsv\")\nwrite_delim(my_data, \"new_data.txt\", delim = \"|\")\n\n# Save R objects\nsaveRDS(my_data, \"my_data.rds\")\n```\n\n### Other File Formats\n\nThe tidyverse ecosystem can also connect with other magical realms:\n\n```r\n# Excel files (requires readxl package)\nlibrary(readxl)\nexcel_data <- read_excel(\"spellbook.xlsx\", sheet = \"Potions\")\n\n# Writing Excel files (requires writexl package)\nlibrary(writexl)\nwrite_xlsx(my_data, \"spellbook.xlsx\")\n\n# SAS files (requires haven package)\nlibrary(haven)\nsas_data <- read_sas(\"wizard_data.sas7bdat\")\n```\n\n### Exercise 3: Data Portal Mastery\n\nPractice your portal creation skills by importing and exporting data:\n\n\n\n::: {.cell exercise='ex_import_1'}\n```{webr}\n#| exercise: ex_import_1\n\n```\n:::\n\n\n\n::: { .hint exercise=\"ex_import_1\"}\n::: { .callout-note collapse=\"false\"}\n## Hint\nUse `read_csv()` to import CSV data and `write_csv()` to export it. Don't forget to peek at your data with `head()` or `glimpse()`!\n:::\n:::\n\n::: { .solution exercise=\"ex_import_1\" }\n::: { .callout-tip collapse=\"false\"}\n## Solution:\n```r\n# Load the tidyverse\nlibrary(tidyverse)\n\n# Create some sample data to export\npotion_recipes <- tibble(\n  potion_name = c(\"Invisibility\", \"Strength\", \"Healing\", \"Flying\", \"Wisdom\"),\n  primary_ingredient = c(\"Ghost Orchid\", \"Dragon Scale\", \"Phoenix Tear\", \"Eagle Feather\", \"Ancient Scroll\"),\n  brewing_time_hours = c(12, 3, 8, 24, 72),\n  potency = c(8, 7, 10, 6, 9)\n)\n\n# Export our potion recipes to CSV\nwrite_csv(potion_recipes, \"potion_recipes.csv\")\n\n# Now import it back\nimported_potions <- read_csv(\"potion_recipes.csv\")\n\n# Let's check if our portal worked correctly\nidentical(potion_recipes, imported_potions)\n\n# Take a peek at our imported data\nglimpse(imported_potions)\n\n# Create a custom column specification\nmy_col_types <- cols(\n  potion_name = col_character(),\n  primary_ingredient = col_character(),\n  brewing_time_hours = col_integer(),\n  potency = col_double()\n)\n\n# Import with specification\nimported_potions_spec <- read_csv(\"potion_recipes.csv\", col_types = my_col_types)\nglimpse(imported_potions_spec)\n```\n:::\n:::\n\n## Subsetting and Sorting: Finding What You Need\n\nSubsetting and sorting data is like having a magical filter and organizer for your data. With just a few spell words, you can find exactly what you need!\n\n### Filtering Rows with `filter()`\n\n`filter()` allows you to select rows based on their values - it's like having a magic sieve that only lets through the data you want!\n\n```r\n# Load a dataset to play with\ndata(starwars, package = \"dplyr\")\nstarwars_tibble <- as_tibble(starwars)\n\n# Filter for humans only - separating humans from aliens!\nhumans <- starwars_tibble %>% \n  filter(species == \"Human\")\n\n# Multiple conditions - finding very tall droids!\ntall_droids <- starwars_tibble %>% \n  filter(species == \"Droid\", height > 100)\n  \n# More complex conditions with logical operators\npowerful_humans <- starwars_tibble %>%\n  filter(species == \"Human\" & (mass > 80 | height > 180))\n  \n# Excluding values\nnon_droids <- starwars_tibble %>%\n  filter(species != \"Droid\")\n  \n# Checking for multiple values\ntatooine_naboo <- starwars_tibble %>%\n  filter(homeworld %in% c(\"Tatooine\", \"Naboo\"))\n```\n\n### Slicing Rows\n\nSometimes you want to select rows by position rather than by values:\n\n```r\n# Get the first 5 rows\nstarwars_tibble %>% slice(1:5)\n\n# Get specific rows\nstarwars_tibble %>% slice(c(1, 3, 5))\n\n# Get the last 5 rows\nstarwars_tibble %>% slice_tail(n = 5)\n\n# Get 3 random rows\nstarwars_tibble %>% slice_sample(n = 3)\n\n# Get 10% of the rows randomly\nstarwars_tibble %>% slice_sample(prop = 0.1)\n\n# Get the 3 tallest characters\nstarwars_tibble %>% slice_max(height, n = 3)\n\n# Get the 3 lightest characters with known mass\nstarwars_tibble %>% slice_min(mass, n = 3, na.rm = TRUE)\n```\n\n### Selecting Columns with `select()`\n\n`select()` lets you focus on just the variables you need - it's like having a magical lens that only shows you what's important!\n\n```r\n# Select only certain columns - focusing your magical lens!\nnames_heights <- starwars_tibble %>% \n  select(name, height, mass)\n\n# Remove columns - banishing unwanted information!\nno_homeworld <- starwars_tibble %>% \n  select(-homeworld, -species)\n  \n# Select columns by position\nfirst_three <- starwars_tibble %>%\n  select(1:3)\n  \n# Use helper functions to select columns matching patterns\nmeasurements <- starwars_tibble %>%\n  select(starts_with(\"h\"), contains(\"mass\"))\n  \n# Select columns by data type\nnumeric_cols <- starwars_tibble %>%\n  select(where(is.numeric))\n  \n# Rename columns while selecting\nrenamed <- starwars_tibble %>%\n  select(character_name = name, height, weight = mass)\n```\n\n### Selection Helpers\n\nThere are many helper functions that make selecting variables easier:\n\n```r\n# Different ways to select variables\nstarwars_tibble %>% select(starts_with(\"h\"))  # Starts with \"h\"\nstarwars_tibble %>% select(ends_with(\"s\"))    # Ends with \"s\"\nstarwars_tibble %>% select(contains(\"o\"))     # Contains \"o\"\nstarwars_tibble %>% select(matches(\"..r.\"))   # Matches regex pattern\nstarwars_tibble %>% select(everything())      # All columns\nstarwars_tibble %>% select(last_col())        # Last column\n```\n\n### Arranging Rows with `arrange()`\n\n`arrange()` allows you to reorder your rows based on the values of selected columns:\n\n```r\n# Sort by height - from shortest to tallest!\nby_height <- starwars_tibble %>% \n  arrange(height)\n\n# Sort by descending mass - heaviest first!\nby_mass_desc <- starwars_tibble %>% \n  arrange(desc(mass))\n  \n# Multiple sort criteria - sort by species, then by height within species\nby_species_height <- starwars_tibble %>%\n  arrange(species, height)\n  \n# Sort by species descending, then by height ascending\ncomplex_sort <- starwars_tibble %>%\n  arrange(desc(species), height)\n```\n\n### Renaming and Relocating Columns\n\nTidyverse also provides tools to rename or reposition your variables:\n\n```r\n# Rename columns\nstarwars_tibble %>%\n  rename(character = name, weight = mass)\n  \n# Rename using a function (convert to uppercase)\nstarwars_tibble %>%\n  rename_with(toupper)\n  \n# Rename only some columns\nstarwars_tibble %>%\n  rename_with(toupper, starts_with(\"h\"))\n  \n# Move columns to different positions\nstarwars_tibble %>%\n  relocate(species, homeworld, .before = name)\n  \nstarwars_tibble %>%\n  relocate(name, species, .after = last_col())\n```\n\n### Exercise 4: The Magic of Subsetting\n\nUse your magical powers to find and sort specific creatures:\n\n\n\n::: {.cell exercise='ex_subset_1'}\n```{webr}\n#| exercise: ex_subset_1\n\n```\n:::\n\n\n\n::: { .hint exercise=\"ex_subset_1\"}\n::: { .callout-note collapse=\"false\"}\n## Hint\nUse `filter()` to find rows meeting certain conditions, `select()` to choose columns, and `arrange()` to sort. Combine them with the magical `%>%` pipe!\n:::\n:::\n\n::: { .solution exercise=\"ex_subset_1\" }\n::: { .callout-tip collapse=\"false\"}\n## Solution:\n```r\n# Load the tidyverse\nlibrary(tidyverse)\n\n# We'll use the built-in starwars dataset\ndata(starwars, package = \"dplyr\")\nstarwars_tibble <- as_tibble(starwars)\n\n# Find all characters taller than 200 cm\ngiants <- starwars_tibble %>% \n  filter(height > 200)\ngiants\n\n# Select only the name, homeworld, and species of characters from Tatooine\ntatooine_chars <- starwars_tibble %>% \n  filter(homeworld == \"Tatooine\") %>%\n  select(name, species, height, mass)\ntatooine_chars\n\n# Find the 5 heaviest characters with known mass\nheaviest_chars <- starwars_tibble %>% \n  filter(!is.na(mass)) %>%\n  arrange(desc(mass)) %>%\n  slice(1:5)\nheaviest_chars\n\n# Find all humans and sort them by height (tallest first)\nsorted_humans <- starwars_tibble %>% \n  filter(species == \"Human\") %>%\n  arrange(desc(height))\nsorted_humans\n\n# Find characters from the same homeworld as Luke Skywalker\nluke_homeworld <- starwars_tibble %>%\n  filter(name == \"Luke Skywalker\") %>%\n  pull(homeworld)\n\nluke_neighbors <- starwars_tibble %>%\n  filter(homeworld == luke_homeworld) %>%\n  select(name, species, height) %>%\n  arrange(species, desc(height))\nluke_neighbors\n\n# Complex pipeline combining multiple operations\nstarwars_analysis <- starwars_tibble %>%\n  # Keep only characters with complete height and mass data\n  filter(!is.na(height), !is.na(mass)) %>%\n  # Calculate BMI\n  mutate(bmi = mass / ((height / 100)^2)) %>%\n  # Select relevant columns\n  select(name, species, gender, height, mass, bmi) %>%\n  # Sort by BMI\n  arrange(desc(bmi)) %>%\n  # Take top 10\n  slice_head(n = 10)\nstarwars_analysis\n```\n:::\n:::\n\n## Creating Variables: Brewing New Data Potions\n\nSometimes you need to create new variables based on existing ones. This is like brewing a new potion by combining ingredients you already have!\n\n### Transforming Variables with `mutate()`\n\n`mutate()` lets you create new variables while preserving existing ones - it's like adding new magical properties to your potion without changing its base ingredients!\n\n```r\n# Add a new column - brewing a new data potion!\nstarwars_bmi <- starwars_tibble %>% \n  filter(!is.na(height), !is.na(mass)) %>%\n  mutate(bmi = mass / ((height / 100)^2))\n\n# Create multiple columns at once - advanced potion brewing!\nstarwars_stats <- starwars_tibble %>% \n  mutate(\n    height_m = height / 100,\n    height_ft = height / 30.48,\n    heavy = mass > 100\n  )\n```\n\n### Conditional Transformations\n\nYou can create variables with values that depend on conditions:\n\n```r\n# Simple if-else condition\nstarwars_tibble %>%\n  mutate(size_category = if_else(height > 180, \"Tall\", \"Short\", missing = \"Unknown\"))\n\n# Multiple conditions with case_when\nstarwars_tibble %>%\n  mutate(\n    size_category = case_when(\n      is.na(height) ~ \"Unknown\",\n      height > 200 ~ \"Very Tall\",\n      height > 180 ~ \"Tall\",\n      height > 160 ~ \"Average\",\n      TRUE ~ \"Short\"\n    )\n  )\n```\n\n### Working Across Multiple Columns\n\nApply the same transformation to multiple columns at once:\n\n```r\n# Apply the same function to multiple columns\nstarwars_tibble %>%\n  mutate(across(c(height, mass), ~ . / mean(., na.rm = TRUE)))\n\n# Apply different functions to different columns\nstarwars_tibble %>%\n  mutate(across(where(is.numeric), ~ round(., 1)))\n\n# Apply multiple functions to the same columns\nstarwars_tibble %>%\n  mutate(across(\n    c(height, mass),\n    list(\n      centered = ~ . - mean(., na.rm = TRUE),\n      scaled = ~ . / sd(., na.rm = TRUE)\n    )\n  ))\n```\n\n### Replacing or Creating New Data Frames\n\nSometimes you want to completely replace your variables instead of adding to them:\n\n```r\n# Replace variables with transmute\nstarwars_tibble %>%\n  transmute(\n    name,\n    height_in_meters = height / 100,\n    weight_in_pounds = mass * 2.2\n  )\n```\n\n### Special Transformation Functions\n\nThe tidyverse provides many functions for common transformations:\n\n```r\n# Ranking\nstarwars_tibble %>%\n  mutate(\n    height_rank = min_rank(height),\n    height_dense_rank = dense_rank(height),\n    height_percent_rank = percent_rank(height)\n  )\n\n# Offset values\nstarwars_tibble %>%\n  mutate(\n    next_mass = lead(mass),\n    prev_mass = lag(mass)\n  )\n\n# Cumulative calculations\nstarwars_tibble %>%\n  mutate(\n    cumulative_mass = cumsum(mass),\n    running_avg = cummean(mass)\n  )\n```\n\n### Exercise 5: Potion Brewing with `mutate()`\n\nBrew some new variables from existing data:\n\n\n\n::: {.cell exercise='ex_mutate_1'}\n```{webr}\n#| exercise: ex_mutate_1\n\n```\n:::\n\n\n\n::: { .hint exercise=\"ex_mutate_1\"}\n::: { .callout-note collapse=\"false\"}\n## Hint\nUse `mutate()` to create new columns based on existing ones. You can create as many new columns as you want in a single `mutate()` spell!\n:::\n:::\n\n::: { .solution exercise=\"ex_mutate_1\" }\n::: { .callout-tip collapse=\"false\"}\n## Solution:\n```r\n# Load the tidyverse\nlibrary(tidyverse)\n\n# Let's create a magical creatures dataset\ncreatures <- tibble(\n  name = c(\"Dragon\", \"Griffin\", \"Phoenix\", \"Unicorn\", \"Basilisk\"),\n  age = c(250, 75, 500, 150, 200),\n  max_age = c(1000, 300, 2000, 500, 800),\n  weight_kg = c(2500, 450, 15, 350, 800),\n  magical_power = c(95, 75, 90, 80, 85)\n)\n\n# Now let's brew some new potions... I mean variables!\ncreatures_enhanced <- creatures %>%\n  mutate(\n    # Calculate age as percentage of maximum lifespan\n    age_percentage = (age / max_age) * 100,\n    \n    # Classify creatures as ancient (over 50% of lifespan) or young\n    age_category = if_else(age_percentage > 50, \"Ancient\", \"Young\"),\n    \n    # Calculate power-to-weight ratio (magical efficiency)\n    power_efficiency = magical_power / weight_kg * 100,\n    \n    # Create a magical threat level\n    threat_level = case_when(\n      magical_power > 90 & weight_kg > 1000 ~ \"Extreme\",\n      magical_power > 80 | weight_kg > 500 ~ \"High\",\n      magical_power > 70 ~ \"Moderate\",\n      TRUE ~ \"Low\"\n    ),\n    \n    # Power rank compared to other creatures\n    power_rank = min_rank(desc(magical_power)),\n    \n    # Normalized power (percentage of max)\n    power_normalized = magical_power / max(magical_power) * 100,\n    \n    # Estimated years left to live\n    years_remaining = max_age - age,\n    \n    # Calculate a weighted magical score\n    magical_score = (magical_power * 0.6) + (power_efficiency * 0.4)\n  )\n\n# Let's see our enhanced creatures dataset!\ncreatures_enhanced %>%\n  arrange(power_rank)\n```\n:::\n:::\n\n## Summaries: Distilling Magical Essences\n\nSummarizing data is like distilling the essence of your dataset down to its most powerful components. It reveals the hidden patterns and secrets!\n\n### Summarizing with `summarize()`\n\n`summarize()` (or `summarise()`, if you prefer British spelling) reduces your dataset to a single row of summary statistics:\n\n```r\n# Calculate basic summaries - distilling the essence!\nheight_summary <- starwars_tibble %>%\n  summarize(\n    avg_height = mean(height, na.rm = TRUE),\n    max_height = max(height, na.rm = TRUE),\n    min_height = min(height, na.rm = TRUE),\n    sd_height = sd(height, na.rm = TRUE),\n    n_characters = n(),\n    n_with_height = sum(!is.na(height))\n  )\n\n# Counting values - counting magical artifacts!\nspecies_count <- starwars_tibble %>%\n  count(species, sort = TRUE)\n```\n\n### Common Summary Functions\n\nHere are some useful functions for creating summaries:\n\n```r\n# Statistical functions\nstarwars_tibble %>%\n  summarize(\n    mean_height = mean(height, na.rm = TRUE),\n    median_height = median(height, na.rm = TRUE),\n    sd_height = sd(height, na.rm = TRUE),\n    var_height = var(height, na.rm = TRUE),\n    min_height = min(height, na.rm = TRUE),\n    max_height = max(height, na.rm = TRUE),\n    q25_height = quantile(height, 0.25, na.rm = TRUE),\n    q75_height = quantile(height, 0.75, na.rm = TRUE)\n  )\n\n# Counting functions\nstarwars_tibble %>%\n  summarize(\n    n_rows = n(),\n    n_species = n_distinct(species),\n    n_homeworlds = n_distinct(homeworld)\n  )\n\n# First, last, and nth values\nstarwars_tibble %>%\n  summarize(\n    first_character = first(name),\n    last_character = last(name),\n    tenth_character = nth(name, 10)\n  )\n```\n\n### Summarizing Multiple Columns\n\nYou can summarize multiple columns at once using `across()`:\n\n```r\n# Apply the same summary function to multiple columns\nstarwars_tibble %>%\n  summarize(across(c(height, mass), mean, na.rm = TRUE))\n\n# Apply different summary functions to different columns\nstarwars_tibble %>%\n  summarize(\n    across(c(height, mass), list(avg = mean, med = median), na.rm = TRUE),\n    across(species, list(n = n_distinct))\n  )\n```\n\n### Exercise 6: The Art of Summary Magic\n\nPractice your summarizing skills on this dataset:\n\n\n\n::: {.cell exercise='ex_summarize_1'}\n```{webr}\n#| exercise: ex_summarize_1\n\n```\n:::\n\n\n\n::: { .hint exercise=\"ex_summarize_1\"}\n::: { .callout-note collapse=\"false\"}\n## Hint\nUse `summarize()` to calculate statistics across the entire dataset, or `group_by()` then `summarize()` to get statistics for each group. The `count()` spell is great for quick frequency tables!\n:::\n:::\n\n::: { .solution exercise=\"ex_summarize_1\" }\n::: { .callout-tip collapse=\"false\"}\n## Solution:\n```r\n# Load the tidyverse\nlibrary(tidyverse)\n\n# Let's work with the built-in mpg dataset\ndata(mpg)\nmpg_tibble <- as_tibble(mpg)\n\n# Overall summary statistics for continuous variables\noverall_summary <- mpg_tibble %>%\n  summarize(\n    avg_mpg = mean(hwy),\n    max_mpg = max(hwy),\n    min_mpg = min(hwy),\n    median_mpg = median(hwy),\n    sd_mpg = sd(hwy),\n    total_cars = n(),\n    efficiency_ratio = mean(hwy) / mean(cty)\n  )\noverall_summary\n\n# Count the number of cars by manufacturer\nmanufacturer_counts <- mpg_tibble %>%\n  count(manufacturer, sort = TRUE)\nmanufacturer_counts\n\n# Group by class and find average mpg\nclass_mpg <- mpg_tibble %>%\n  group_by(class) %>%\n  summarize(\n    avg_city_mpg = mean(cty),\n    avg_hwy_mpg = mean(hwy),\n    mpg_difference = mean(hwy - cty),\n    car_count = n(),\n    manufacturers = n_distinct(manufacturer)\n  ) %>%\n  arrange(desc(avg_hwy_mpg))\nclass_mpg\n\n# Find the most fuel-efficient car in each class\nbest_in_class <- mpg_tibble %>%\n  group_by(class) %>%\n  slice_max(order_by = hwy, n = 1) %>%\n  select(class, manufacturer, model, hwy) %>%\n  arrange(desc(hwy))\nbest_in_class\n\n# Create a comprehensive efficiency report by manufacturer\nmanufacturer_report <- mpg_tibble %>%\n  group_by(manufacturer) %>%\n  summarize(\n    models = n_distinct(model),\n    avg_city = mean(cty),\n    avg_hwy = mean(hwy),\n    best_hwy = max(hwy),\n    worst_hwy = min(hwy),\n    range = max(hwy) - min(hwy),\n    total_cars = n()\n  ) %>%\n  # Only include manufacturers with at least 3 cars\n  filter(total_cars >= 3) %>%\n  # Sort by average highway MPG\n  arrange(desc(avg_hwy))\nmanufacturer_report\n```\n:::\n:::\n\n## Group Operations: Organizing Your Magical Creatures\n\nGrouping allows you to perform operations on subsets of your data. It's like organizing your magical creatures by species before studying them!\n\n### Grouping with `group_by()`\n\n`group_by()` transforms your data frame into a grouped data frame, where operations are performed \"by group\":\n\n```r\n# Group by species and find average height/mass\nspecies_stats <- starwars_tibble %>%\n  group_by(species) %>%\n  summarize(\n    count = n(),\n    avg_height = mean(height, na.rm = TRUE),\n    avg_mass = mean(mass, na.rm = TRUE)\n  ) %>%\n  filter(count > 1)  # Only include species with more than 1 character\n\n# Find max height by gender and homeworld\nmax_heights <- starwars_tibble %>%\n  group_by(homeworld, gender) %>%\n  summarize(\n    tallest = max(height, na.rm = TRUE),\n    n = n()\n  ) %>%\n  filter(!is.na(tallest), !is.na(homeworld))\n```\n\n### Grouping by Multiple Variables\n\nYou can group by multiple variables to create nested groups:\n\n```r\n# Group by species and gender\nstarwars_tibble %>%\n  group_by(species, gender) %>%\n  summarize(\n    count = n(),\n    avg_height = mean(height, na.rm = TRUE)\n  )\n\n# Getting the number of groups\nstarwars_tibble %>%\n  group_by(species, gender) %>%\n  summarize(count = n()) %>%\n  nrow()\n\n# Getting information about the groups\nstarwars_groups <- starwars_tibble %>% group_by(species, gender)\ngroup_keys(starwars_groups)\nn_groups(starwars_groups)\n```\n\n### Group Mutations\n\nYou can use `group_by()` with `mutate()` to compute values within each group:\n\n```r\n# Calculate z-scores within species groups\nstarwars_tibble %>%\n  group_by(species) %>%\n  filter(n() > 1) %>%  # Only species with multiple members\n  mutate(\n    height_avg = mean(height, na.rm = TRUE),\n    height_sd = sd(height, na.rm = TRUE),\n    height_z = (height - height_avg) / height_sd\n  ) %>%\n  select(name, species, height, height_avg, height_z) %>%\n  arrange(species, desc(height_z))\n\n# Rank heights within each species\nstarwars_tibble %>%\n  group_by(species) %>%\n  filter(n() > 1) %>%\n  mutate(height_rank = min_rank(desc(height))) %>%\n  select(name, species, height, height_rank) %>%\n  arrange(species, height_rank)\n```\n\n### Managing Groups\n\nYou can add or remove grouping variables:\n\n```r\n# Add a grouping variable\nstarwars_tibble %>%\n  group_by(species) %>%\n  group_by(gender, .add = TRUE)  # Keep species grouping and add gender\n\n# Remove all grouping\nstarwars_tibble %>%\n  group_by(species, gender) %>%\n  ungroup()\n```\n\n### Row-wise Operations\n\nFor operations across rows (rather than down columns), use `rowwise()`:\n\n```r\n# Calculate the sum of height and mass for each character\nstarwars_tibble %>%\n  rowwise() %>%\n  mutate(\n    height_plus_mass = sum(c(height, mass), na.rm = TRUE)\n  )\n\n# Find the maximum value across several columns\nstarwars_tibble %>%\n  rowwise() %>%\n  mutate(\n    max_value = max(c(height, mass), na.rm = TRUE)\n  )\n```\n\n### Exercise 7: The Power of Grouping\n\nUse grouping to analyze this dataset of magical creatures:\n\n\n\n::: {.cell exercise='ex_group_1'}\n```{webr}\n#| exercise: ex_group_1\n\n```\n:::\n\n\n\n::: { .hint exercise=\"ex_group_1\"}\n::: { .callout-note collapse=\"false\"}\n## Hint\nUse `group_by()` followed by `summarize()` to calculate statistics for each group. Try grouping by multiple variables to dig deeper!\n:::\n:::\n\n::: { .solution exercise=\"ex_group_1\" }\n::: { .callout-tip collapse=\"false\"}\n## Solution:\n```r\n# Load the tidyverse\nlibrary(tidyverse)\n\n# Create a dataset of potions sold at a magical marketplace\npotions_sales <- tibble(\n  potion_type = rep(c(\"Healing\", \"Strength\", \"Invisibility\", \"Love\", \"Wisdom\"), each = 20),\n  merchant = rep(c(\"Elixir Emporium\", \"Witch's Brew\", \"Magical Mixtures\", \"Cauldron Creations\"), times = 25),\n  price = c(\n    # Healing potions prices\n    runif(20, 10, 20),\n    # Strength potions prices\n    runif(20, 15, 30),\n    # Invisibility potions prices\n    runif(20, 25, 50),\n    # Love potions prices\n    runif(20, 5, 15),\n    # Wisdom potions prices\n    runif(20, 20, 40)\n  ),\n  quantity_sold = sample(1:10, 100, replace = TRUE),\n  customer_rating = sample(1:5, 100, replace = TRUE, prob = c(0.05, 0.1, 0.2, 0.4, 0.25))\n)\n\n# Calculate average price by potion type\navg_prices <- potions_sales %>%\n  group_by(potion_type) %>%\n  summarize(\n    avg_price = mean(price),\n    median_price = median(price),\n    min_price = min(price),\n    max_price = max(price),\n    price_range = max_price - min_price,\n    total_sold = sum(quantity_sold),\n    avg_rating = mean(customer_rating)\n  ) %>%\n  arrange(desc(avg_price))\navg_prices\n\n# Find total revenue by merchant and potion type\nmerchant_revenue <- potions_sales %>%\n  mutate(revenue = price * quantity_sold) %>%\n  group_by(merchant, potion_type) %>%\n  summarize(\n    total_revenue = sum(revenue),\n    avg_price = mean(price),\n    total_sold = sum(quantity_sold),\n    avg_rating = mean(customer_rating)\n  ) %>%\n  arrange(merchant, desc(total_revenue))\nmerchant_revenue\n\n# Find the most profitable potion type for each merchant\nbest_potions <- potions_sales %>%\n  mutate(revenue = price * quantity_sold) %>%\n  group_by(merchant, potion_type) %>%\n  summarize(total_revenue = sum(revenue)) %>%\n  ungroup() %>%\n  group_by(merchant) %>%\n  slice_max(order_by = total_revenue, n = 1)\nbest_potions\n\n# Calculate the average rating for each merchant and how it compares to overall average\nrating_analysis <- potions_sales %>%\n  group_by(merchant) %>%\n  summarize(\n    avg_rating = mean(customer_rating),\n    total_ratings = n()\n  ) %>%\n  ungroup() %>%\n  mutate(\n    overall_avg = mean(potions_sales$customer_rating),\n    rating_difference = avg_rating - overall_avg,\n    performance = case_when(\n      rating_difference > 0.5 ~ \"Excellent\",\n      rating_difference > 0 ~ \"Above Average\",\n      rating_difference > -0.5 ~ \"Average\",\n      TRUE ~ \"Below Average\"\n    )\n  ) %>%\n  arrange(desc(avg_rating))\nrating_analysis\n\n# Advanced analysis: Find which merchants are specialized in certain potions\nspecialization_analysis <- potions_sales %>%\n  group_by(merchant, potion_type) %>%\n  summarize(\n    potion_count = n(),\n    potion_revenue = sum(price * quantity_sold)\n  ) %>%\n  group_by(merchant) %>%\n  mutate(\n    total_potions = sum(potion_count),\n    total_revenue = sum(potion_revenue),\n    potion_percent = potion_count / total_potions * 100,\n    revenue_percent = potion_revenue / total_revenue * 100,\n    is_specialized = potion_percent > 30 | revenue_percent > 40\n  ) %>%\n  filter(is_specialized) %>%\n  select(merchant, potion_type, potion_percent, revenue_percent) %>%\n  arrange(merchant, desc(revenue_percent))\nspecialization_analysis\n```\n:::\n:::\n\n## Capstone Project: The Ultimate Tidyverse Spell\n\nNow it's time to combine all your tidyverse skills into one magnificent spell! Create a comprehensive analysis of magical creatures and their powers.\n\n### The Complete Tidyverse Wizard\n\nA true tidyverse wizard can combine all their magical spells - tibbles, importing, filtering, arranging, mutating, summarizing, and grouping - into a single powerful workflow. Let's put everything together!\n\nHere's what your capstone should demonstrate:\n- Creating and transforming tibbles\n- Importing and cleaning data\n- Filtering and selecting relevant information\n- Creating new variables\n- Summarizing by groups\n- Visualizing results (if desired)\n- Exporting your processed data\n\n### Exercise 8: The Complete Tidyverse Magic System\n\n\n\n::: {.cell exercise='ex_capstone_1'}\n```{webr}\n#| exercise: ex_capstone_1\n\n```\n:::\n\n\n\n::: { .hint exercise=\"ex_capstone_1\"}\n::: { .callout-note collapse=\"false\"}\n## Hint\nCombine all the magical spells you've learned - create tibbles, import/export data, filter, select, arrange, mutate, summarize, and group. Think of it as creating your own complete magical analysis system!\n:::\n:::\n\n::: { .solution exercise=\"ex_capstone_1\" }\n::: { .callout-tip collapse=\"false\"}\n## Solution:\n```r\n# Load the tidyverse - our magical toolkit\nlibrary(tidyverse)\n\n# Create a comprehensive magical creature database\nmagical_creatures <- tibble(\n  species = c(\"Dragon\", \"Phoenix\", \"Unicorn\", \"Griffin\", \"Mermaid\", \"Centaur\", \n              \"Basilisk\", \"Fairy\", \"Troll\", \"Werewolf\", \"Vampire\", \"Ghost\",\n              \"Dragon\", \"Unicorn\", \"Griffin\", \"Fairy\", \"Phoenix\", \"Mermaid\"),\n  name = c(\"Smaug\", \"Fawkes\", \"Twilight\", \"Buckbeak\", \"Ariel\", \"Firenze\", \n           \"Slytherin\", \"Tinkerbell\", \"Grumpy\", \"Remus\", \"Dracula\", \"Casper\",\n           \"Norbert\", \"Silver\", \"Talon\", \"Periwinkle\", \"Ash\", \"Marina\"),\n  age = c(250, 500, 150, 75, 120, 80, 200, 50, 100, 45, 300, 150,\n          100, 50, 120, 25, 300, 80),\n  power_level = c(95, 90, 70, 75, 60, 65, 85, 40, 60, 70, 80, 50,\n                 80, 65, 70, 35, 85, 55),\n  habitat = c(\"Mountain\", \"Volcano\", \"Forest\", \"Mountain\", \"Ocean\", \"Forest\", \n              \"Cave\", \"Forest\", \"Mountain\", \"Forest\", \"Castle\", \"Haunted House\",\n              \"Mountain\", \"Forest\", \"Mountain\", \"Forest\", \"Volcano\", \"Ocean\"),\n  element = c(\"Fire\", \"Fire\", \"Light\", \"Air\", \"Water\", \"Earth\", \n              \"Poison\", \"Light\", \"Earth\", \"Moon\", \"Blood\", \"Spirit\",\n              \"Fire\", \"Light\", \"Air\", \"Light\", \"Fire\", \"Water\"),\n  is_friendly = c(FALSE, TRUE, TRUE, TRUE, TRUE, TRUE, \n                 FALSE, TRUE, FALSE, FALSE, FALSE, TRUE,\n                 FALSE, TRUE, FALSE, TRUE, TRUE, TRUE)\n)\n\n# Export our original dataset to CSV\nwrite_csv(magical_creatures, \"magical_creatures.csv\")\n\n# Re-import and verify (in a real workflow, you might combine these steps)\ncreatures_imported <- read_csv(\"magical_creatures.csv\")\n\n# ===== STEP 1: DATA CLEANING AND ENRICHMENT =====\ncreatures_enhanced <- creatures_imported %>%\n  # Remove duplicates \n  distinct() %>%\n  # Add calculated fields\n  mutate(\n    # Create power categories\n    power_category = case_when(\n      power_level >= 85 ~ \"Supreme\",\n      power_level >= 70 ~ \"High\",\n      power_level >= 50 ~ \"Moderate\",\n      TRUE ~ \"Low\"\n    ),\n    # Age categories\n    age_category = case_when(\n      age >= 200 ~ \"Ancient\",\n      age >= 100 ~ \"Old\",\n      age >= 50 ~ \"Adult\",\n      TRUE ~ \"Young\"\n    ),\n    # Danger assessment\n    danger_level = if_else(\n      power_level > 80 & !is_friendly, \n      \"Extremely Dangerous\",\n      if_else(power_level > 60 & !is_friendly, \"Dangerous\",\n             if_else(!is_friendly, \"Exercise Caution\", \"Generally Safe\"))\n    ),\n    # Normalized power (as a percentage of maximum)\n    power_normalized = round(power_level / max(power_level) * 100, 1),\n    # Create a magical power index\n    magic_index = (power_level * 0.6) + (age * 0.4 / 10)\n  )\n\n# ===== STEP 2: SPECIES ANALYSIS =====\nspecies_analysis <- creatures_enhanced %>%\n  group_by(species) %>%\n  summarize(\n    count = n(),\n    avg_power = mean(power_level),\n    max_power = max(power_level),\n    min_power = min(power_level),\n    power_range = max_power - min_power,\n    avg_age = mean(age),\n    pct_friendly = mean(is_friendly) * 100\n  ) %>%\n  arrange(desc(avg_power))\n\n# ===== STEP 3: HABITAT ANALYSIS =====\nhabitat_analysis <- creatures_enhanced %>%\n  group_by(habitat, element) %>%\n  summarize(\n    creature_count = n(),\n    avg_power = mean(power_level),\n    most_dangerous = max(power_level),\n    pct_friendly = mean(is_friendly) * 100\n  ) %>%\n  arrange(habitat, desc(avg_power))\n\n# ===== STEP 4: ELEMENT CHAMPIONS =====\nelement_champions <- creatures_enhanced %>%\n  group_by(element) %>%\n  slice_max(order_by = power_level, n = 1) %>%\n  select(element, name, species, power_level, danger_level) %>%\n  arrange(desc(power_level))\n\n# ===== STEP 5: FRIENDSHIP ANALYSIS =====\nfriendship_analysis <- creatures_enhanced %>%\n  group_by(power_category, is_friendly) %>%\n  summarize(\n    count = n(),\n    avg_age = mean(age),\n    avg_power = mean(power_level)\n  ) %>%\n  arrange(power_category, desc(is_friendly))\n\n# ===== STEP 6: FEATURE CORRELATION =====\n# Checking relationship between power and age\npower_age_correlation <- cor(creatures_enhanced$power_level, \n                            creatures_enhanced$age,\n                            method = \"pearson\")\n\n# ===== STEP 7: DANGER ASSESSMENT =====\ndanger_assessment <- creatures_enhanced %>% \n  filter(danger_level == \"Extremely Dangerous\") %>% \n  select(name, species, habitat, power_level, element)\n\n# ===== STEP 8: ADVANCED FILTERING =====\n# Find creatures matching specific criteria\nspecial_creatures <- creatures_enhanced %>%\n  filter(\n    (element %in% c(\"Fire\", \"Water\")) &\n    (power_level > 70 | age > 200) &\n    (habitat != \"Cave\")\n  ) %>%\n  select(name, species, element, habitat, power_level, age) %>%\n  arrange(desc(power_level))\n\n# ===== STEP 9: CREATE FINAL REPORT =====\nmagical_report <- list(\n  dataset_summary = list(\n    creature_count = nrow(creatures_enhanced),\n    species_count = n_distinct(creatures_enhanced$species),\n    habitat_count = n_distinct(creatures_enhanced$habitat),\n    element_count = n_distinct(creatures_enhanced$element),\n    avg_power_level = mean(creatures_enhanced$power_level),\n    avg_age = mean(creatures_enhanced$age),\n    friendly_pct = mean(creatures_enhanced$is_friendly) * 100,\n    power_age_correlation = power_age_correlation\n  ),\n  most_powerful = creatures_enhanced %>% \n                  slice_max(order_by = power_level, n = 1) %>% \n                  select(name, species, power_level, element),\n  oldest_creature = creatures_enhanced %>%\n                   slice_max(order_by = age, n = 1) %>%\n                   select(name, species, age, power_level),\n  species_analysis = species_analysis,\n  habitat_analysis = habitat_analysis,\n  element_champions = element_champions,\n  friendship_analysis = friendship_analysis,\n  danger_assessment = danger_assessment,\n  special_creatures = special_creatures\n)\n\n# Show the complete report\nmagical_report\n```\n:::\n:::\n\n## Advanced Tidyverse Topics: Mastering the Arcane Arts\n\nFor those who wish to continue their magical journey, here are some advanced tidyverse topics to explore:\n\n### The Magic of Joins\n\nCombining datasets is like merging two magical potions to create something even more powerful:\n\n```r\n# Create two datasets\nwizards <- tibble(\n  name = c(\"Gandalf\", \"Dumbledore\", \"Merlin\", \"Elminster\"),\n  element = c(\"Light\", \"Fire\", \"Earth\", \"Air\"),\n  power = c(95, 92, 99, 90)\n)\n\nspells <- tibble(\n  caster = c(\"Gandalf\", \"Gandalf\", \"Dumbledore\", \"Merlin\", \"Unknown\"),\n  spell = c(\"Light Beam\", \"Flame Shield\", \"Phoenix Call\", \"Earth Shake\", \"Tempest\"),\n  power_cost = c(20, 35, 40, 50, 60)\n)\n\n# Inner join - only keeps matching rows\ninner_join(wizards, spells, by = c(\"name\" = \"caster\"))\n\n# Left join - keeps all rows from the left table\nleft_join(wizards, spells, by = c(\"name\" = \"caster\"))\n\n# Right join - keeps all rows from the right table\nright_join(wizards, spells, by = c(\"name\" = \"caster\"))\n\n# Full join - keeps all rows from both tables\nfull_join(wizards, spells, by = c(\"name\" = \"caster\"))\n```\n\n### The Art of Pivoting\n\nReshaping data is like transforming your magical creatures into different forms:\n\n```r\n# Wide to long format\nmeasurements <- tibble(\n  name = c(\"Dragon\", \"Phoenix\", \"Unicorn\"),\n  height = c(300, 120, 180),\n  weight = c(2000, 15, 450),\n  wingspan = c(500, 300, NA)\n)\n\n# Convert to long format\nmeasurements_long <- measurements %>%\n  pivot_longer(\n    cols = c(height, weight, wingspan),\n    names_to = \"measurement\",\n    values_to = \"value\"\n  )\n\n# Long to wide format\nmeasurements_wide <- measurements_long %>%\n  pivot_wider(\n    names_from = measurement,\n    values_from = value\n  )\n```\n\n### Working with Nested Data\n\nNested data is like having magical creatures with smaller creatures inside them:\n\n```r\n# Group and nest data\nnested_creatures <- magical_creatures %>%\n  group_by(species) %>%\n  nest()\n\n# Work with nested data\nnested_creatures %>%\n  mutate(\n    creature_count = map_int(data, nrow),\n    power_stats = map(data, ~ summary(.$power_level)),\n    max_power = map_dbl(data, ~ max(.$power_level))\n  )\n\n# Unnest data\nnested_creatures %>%\n  unnest(data)\n```\n\nWith these advanced techniques in your magical arsenal, there's no data enchantment you can't master!\n\n### Further Learning\n\nTo continue your journey to becoming a tidyverse archmage, consult these magical tomes:\n- [R for Data Science](https://r4ds.had.co.nz/)\n- [tidyverse.org](https://www.tidyverse.org/)\n- [RStudio Cheatsheets](https://www.rstudio.com/resources/cheatsheets/) ",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}